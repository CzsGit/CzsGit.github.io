<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python spider get方法的封装]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F22%2FPython-spider-get%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%81%E8%A3%85.html</url>
    <content type="text"><![CDATA[大家经常使用Python3的urllib库进行get请求，得到数据，来封装爬虫的行为。下面封装了一个方法供大家参考使用：这里比较规范的使用了工程化的思想，考虑了日志的编写；爬虫发送get请求时，则考虑了UA等http request head部分的设置；并且支持代理服务器的信息处理；返回的状态码不是200时的处理；并且考虑了超时问题，及网页的编码问题 import sys import logging import urllib import random import time import socket timeout = 15 socket.setdefaulttimeout(timeout)#这里对整个socket层设置超时时间。后续文件中如果再使用到socket，不必再设置 # 创建日志的实例 logger = logging.getLogger(&quot;basicSpider&quot;) # 定制Logger的输出格式 formatter = logging.Formatter(&quot;%(asctime)s %(levelname)s %(message)s&quot;) # 创建日志:文件日志，终端日志 file_handler = logging.FileHandler(&apos;basicSpider.log&apos;) file_handler.setFormatter(formatter) consle_handler = logging.StreamHandler(sys.stdout) consle_handler.setFormatter(formatter) # 设置默认的日志级别 logger.setLevel(logging.INFO) # 把文件日志和终端日志添加到日志处理器中 logger.addHandler(file_handler) logger.addHandler(consle_handler) PROXY_RANGE_MIN = 1 PROXY_RANGE_MAX = 10 PROXY_RANGE = 10 NUM = 10 def downloadHtml(url, headers=[], proxy={}, num_retries=NUM, timeout=NUM, decodeInfo=&quot;utf-8&quot;): &quot;&quot;&quot; 爬虫的get请求，考虑了UA等http request head部分的设置； 支持代理服务器的信息处理； 返回的状态码不是200，这时怎么处理； 考虑超时问题，及网页的编码问题 &quot;&quot;&quot; html = None if num_retries &lt;= 0: return html # 一般来说，使用UA池和Proxy池相结合的方式来访问某个页面，会 #更加的不容易被反爬。 # 动态的调整代理服务器的使用策略 if random.randint(PROXY_RANGE_MIN,PROXY_RANGE_MAX) &gt; PROXY_RANGE: logger.info(&quot;No Proxy&quot;) proxy = None proxy_handler = urllib.request.ProxyHandler(proxy) # 替换handler，以实现可以处理Proxy opener = urllib.request.build_opener(proxy_handler) # 把opener装载进urllib库中，准备使用 opener.addheaders = headers urllib.request.install_opener(opener) try: response = urllib.request.urlopen(url) html = response.read().decode(decodeInfo) except UnicodeDecodeError: logger.error(&quot;UnicodeDecodeError&quot;) except urllib.error.URLError or \ urllib.error.HTTPError as e: logger.error(&quot;urllib error %s&quot;%e.__str__) if hasattr(e,&apos;code&apos;) and 400 &lt;= e.code &lt; 500: logger.error(&quot;Client Error %d&quot;%e.code) # 客户端问题，通过分析日志来跟踪 elif hasattr(e,&apos;code&apos;) and 500 &lt;= e.code &lt; 600: html = downloadHtml(url, headers, proxy, timeout, decodeInfo, num_retries-1) time.sleep(PROXY_RANGE)# 休息的时间可以自己定义一个策略 except Exception as e: logger.error(&quot;Download error reson is %s&quot;%e.reson) urllib.request.close()#记得要关闭 return html if __name__ == &quot;__main__&quot;: url = &quot;http://www.sina.com.cn&quot; headers = [(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot;)] # 注意：这里的UA和Proxy可以根据自己的需求来改变，也可以对它们使用池来随机取值 proxy = {&quot;http&quot;:&quot;182.129.243.84:9000&quot;} print(downloadHtml(url, headers, proxy)) logger.removeHandler(file_handler) logger.removeHandler(consle_handler)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[余弦相似度和欧氏距离的区别]]></title>
    <url>%2F%2Fblog%2F2018%2F07%2F16%2F%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%92%8C%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[Basic Vector Space Search Engine Theory LA2600– January2, 2004 - presented by VidiotOverview:A Vector Space Search Engine uses very simple techniques from matrix algebra to compare documents based on word frequency.The first major component of a vector space search engine is the concept of a term space. Simply put, a term space consists of every unique word thatappears in a collection of documents.The second major component of a vector space search engine is term counts.Term counts are simply records of how many times each term occurs in anindividual document. This is usually represented as a table, as in the illustration below. By using the term space as a coordinate space, and the term counts ascoordinates within that space, we can create a vectorfor each document. Inorder to understand how we create these vectors, let’s look at a simple example. You’re probably familiar with Cartesian Coordinates; plotting points along X, Y,and Z axes. Similarly, in the case of a term space containing three unique terms we would refer to these axes as the term1, term2, and term3axes. (In vectorspace search theory these axes are usually referred to as dimensions.) Bycounting how many times each term appears in a document, and plotting thecoordinates along each term dimension, we can determine a point in the termspacethat corresponds to the document. Using this point we can then create avector for the document back to the origin. Once we have plotted the vector of a document through the term space, we can then calculate the magnitude of the vector. Think of the magnitude as the length of the line between the documents point in the term space and the origin of theterm space(at coordinates(0,0,0) in our example). These vector magnitudes will allow us to compare documents by calculating the cosign of the angle betweenthem. For example, identical documents will have a cosign of1, documentscontaining similar terms will have positive decimal cosigns, and documents withnothing in common will have cosigns of zero. A Simple Example:In this tutorial we’ll go through the entire indexing and search process using a simple three dimensional example that is easy to envision.To begin, lets assume we have a collection of three documents. Each document contains combinations of the words cat, dog, and mouse. The words cat, dog,and mouse are the term space. Thus we can say that each document hascoordinates along the cat, dog, and mousedimensions. These coordinates are two dimensions, so the formula would be:a2+b2+c2=d21,000 unique words, and thus 1,000 dimensions, the formula would continue to be a2+b2+c2+d2+e2…etc., 995 more times until we reach our answer.__Q = (02)+(02)+(12)= 0+0+1 = 1=12 determined by how many times each term appears in the document. Forexample, document 1 below would have a “cat-dog-mouse vector” of (3,1 ,4). We calculate the magnitude of the vector for each document using the PythagoreanTheorem, but in this case we have more than V1 = (32)+(12)+(42)= 9+1 +16= 26=5.09901 V2 = (12)+(22)+(52) = 1 +4+25= 30=5.47722 V3 = (22)+(32)+(02)= 4+9+0 = 15=3.87298NOTE: The two vertical bars on each side of the vector variable mean “the magnitude of”. Note that the Pythagorean Theorem formula will continue to apply no matter how many dimensions we are working with. For example, if we had a term space with Also, the astute observer may have noticed that different documents can have the exact same vector magnitudes. For example, two different documents with vectors of (1,2,3) and (3,2,1) would both have a vector magnitude of 3.74165. This is not a contradiction. As we will see, relevancy scores of documents are based on the dimensionality of the query term that is searched for, thus documents with identical vector magnitudes can return very different query results. In other words, just because two lines are the same length, it doesn’t necessarily mean that they are pointing to the same angle within the term space.Querying :To query the document collection index, we project the vector of our query into the vector space, and then calculate the cosign of the angle between the query and each of the other documents in the collection. In English, this means we project the query vector into the vector space, and then see what other document vectors are nearby.For example, if the query term is “mouse”, then the “cat-dog-mouse vector” would be (0,0,1). The magnitude of our query vector would then be: 3 NOTE: A simple optimization while coding is to check if the query term is in the termspace, and if so, then Q will always = 1 , but this only works with a single searchterm. For multiple search terms, count how many are within the term space, and take the square root of the count. Because query terms are not represented as values less than 1 , the solution to Q will always be the square root of a whole number. But this assumes that each term appears only once in each query, which is not necessarily agood assumption because of word stemming which I will discuss shortly.To calculate the cosign between the query and a document vector, we divide the Dot Productof the query vector and the document vector, by the magnitude of the query vector multiplied by the magnitude of the document vector. Q * V1_ Q x V1The Dot Productis the sum of the term counts for each document and thecorresponding query term counts multiplied together. For example, if we were to search for the term “mouse”, the coordinates for the Query would be (0,0,1)because the words cat and dog do not appear and the word mouse appearsonce is the third dimension of the term space. Document 1 in our examplecollection would have a vector of (3,1 ,4) based on the term counts listed in thetable above. If we wanted to calculate the Dot Product between the Query andDocument 1 we would make the following calculation: Now we divide the Dot Product of 4, by the product of the query and document magnitudes, to get the cosine value. As we saw earlier the magnitude of thevector of Document 1 is 5.09901 , and the magnitude of the Query vector = 1 . Thus the cosign value is 4 divided by 5.09901 .Let’s try it out. The cosign of the angle between the query for “mouse”, and Document 1 would be calculated by: Q * V1 Q x V1= (0x3)+(0x1)+(1x4)=4= 0.784461x 5.09901 5.09901 NOTE: If a document doesn’t contain any relevant search terms from the query, the Dot Productwill be zero, because zero divided by any value is still zero, thus the cosign will also be zero. This is good to remember while writing efficient code.If we performed this calculation for the other two documents we would get the following cosigns: orthogonal in the term space and are not related. Collection Indexing Processoptimized to make the indexing process more efficient.As an example, let’s assume we want to index a small website.4 Doc 1 = 0.78446 Doc 2 = 0.91287 Doc 3 = 0.00000By arranging the documents in descending order according to the cosigns, as so:Doc 2 = 0.91287 Doc 1 = 0.78446 Doc 3 = 0.00000…we can see that document 2 is the most relevant to the query of “mouse”, and a quick glance at our term counts table above will confirm this. Document 1 isslightly less relevant, and Document 3 is completely irrelevant, because it doesn’t contain any instances of the word “mouse”.An easy way to think of this is that the closer the cosign value is to 1 , the more relevant the document is. If the cosign is zero, then the documents are The process of indexing a collection is specific to the type of documents beingindexed. Vector Space search technology can be used on any type information that can be represented in a structured fashion, so it will work equally well ontext, images, cryptographic keys, or even DNA. However, custom parsers must be constructed to handle the information in a regulated fashion, and can often be First each HTML document must be pre-processed, and then indexed as part of a collection. (Collections can only be indexed as a whole. Adding additional files to a collection after it has been indexed changes the dimensionality of the termspace and negates the stored document vector magnitudes.)We begin by stripping out all the HTML content because is contains no semantic content. We can also strip out any formatting such as line breaks and carriage returns so that we are left with a simple block of text. Next, we remove stop words from the text. Stop words are words that occurcommonly in the English language, but don’t add any semantic value to the text as a whole. For example, words like “the”, “and”, “of”, and “or” are irrelevant tothe actual semantic meaning of the document but would artificially enlarge theterm space, and thus the processing time, if they were left in. Also adverbs such as “quickly” (or anything typically ending in “ly”) can be removed because theydon’t add any additional semantic value. Remove Stop WordsStem Termsexperiment to find the optimal partitions within particular data.Vector Space Search Engine Limitations:Despite how cool Vector Space search technology is, it does have some serious limitations.5 Next, we stemthe remaining terms in the document. Stemming consists ofreducing English word to their root word forms. For example, the words “runner”, “running”, and “runs” would all be stemmed to the word “run.” The PorterStemming Algorithm is typically used for this purpose. This further reduces theterm space while maintaining semantic content. After we have finished with these three steps we are left with (hopefully) theminimal number of terms required to contain the semantic meaning of the original document.No we can begin indexing the collection by building the term space and calculating the vector magnitude of each document. Step 1 – Strip out HTML, punctuation, and line breaks to leave only blocked textualcontent.Step 2 – Remove stop words (such as “the”) to reduce the size of the term space.Step 3 – Stem the remaining terms to further reduce the size of the term space whilemaintaining semantic content. For example, “runner” and “running” will both bestemmed to “run”. The Porter stemming algorithm is commonly used for this purpose. Step 4A – Populate the term space with one unique instance of each term, from everydocument, that spans across the entire collection so that all possible terms are included. Store the results.Step 4B – Count and record how many times each relevant term appears in eachdocument.Step 4C – Calculate and record the vector magnitude, Vn , for each document.NOTE: It is important to keep in mind that how the parser divides up information will affect the search results. For example, if you were indexing the contents of a book, the indexing time and search results would differ greatly depending onwhether you broke the text up by chapter, page, or paragraph. You will need to First, it is VERY calculation intensive, and therefore quite slow. Because of allthe floating-point mathematics, it requires lots and lots of processor time, whichkills performance. High performance requires large systems with code optimized to run calculations exclusively in RAM. Hopefully, this will become less of abarrier as processor speeds continue to increase. building a vector space search engine including open source PERL code. • http://www.chuggnutt.com/stemmer.php - Open source implementation ofthe Porter stemming algorithm in PHP• http://www.nitle.org/semantic_search.php - Open source Latent SemanticIndexing package written in Perl. Very much in Beta, not yet suitable forproduction.• http://lsi.argreenhouse.com/- Closed source online Latent SemanticIndexing demo by Telecordia Technologies• “Using LinearAlgebrafor Information Retrieval” - Berry, M. W.; Dumais,S. T.; and O’Brien, G. W. 1995.• “Indexing by latent semantic analysis.” Journal of the Society forInformation Science, 41 (6), 391-407. — first technical Latent SemanticIndexing paper; good background.• “Enhancing Performance in Latent Semantic Indexing Retrieval” - SusanDumais, TM-ARH-017527 Technical Report, Bellcore, 19906 Second, dynamic collections will (usually) require re-indexing each time a new document is added. This is because every time you introduce a new term into the term space, you are adding another dimension to the matrix, and all existing documents must be re-indexed so that their vectors are relevant to the newdimensionality. This is perhaps the most serious barrier to the widespreadadoption of this technology because it makes real time availability of searchresults next to impossible.Third, it requires additional mathematical transformation of the collection matrix in order to detect additional connections between documents with Latent Semantic Indexing. LSI allows us to find additional connections between documents on a semantic level. It is outside the scope of this document, but it is an importantnext-step in Vector Space search technology, and another barrier to real timeusability.Resources and Additional Reading• http://www.perl.com/pub/a/2003/02/19/engine.html - Excellent article about]]></content>
      <categories>
        <category>Verification</category>
      </categories>
      <tags>
        <tag>Verification</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[info函数的封装]]></title>
    <url>%2F%2Fblog%2F2018%2F05%2F22%2Finfo%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85.html</url>
    <content type="text"><![CDATA[大家在使用Python help或者info查看信息时，有时显得很不灵活，冗长并且全英文（可能对一些英文不太好的人而言不方便）。于是，我就封装了下面一个小方法，可以实现将模块或者函数的名称和doc string的中文解释对应上。这里的中文解释来源于有道词典的网络API数据抓取。 本代码推荐使用使用环境是Python3.5及以上版本，我测试的是Anaconda3-5.1.0-Windows-x86_64.exe版本；123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import urllib.requestimport http.clientimport requestsimport jsonimport refrom urllib import request,parsedef getTInfo(key): # 通过抓包的方式获取的url，并不是浏览器上显示的url url = "http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=null" # 完整的headers headers = &#123; "Accept" : "application/json, text/javascript, */*; q=0.01", "X-Requested-With" : "XMLHttpRequest", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0", "Content-Type" : "application/x-www-form-urlencoded; charset=UTF-8", &#125; formdata = &#123; "i":key, "from":"auto", "to":"auto", "smartresult":"dict", "client":"fanyideskweb", "salt":"1511219405946", "sign":"f8965f67a1d3eee8a69ddf8ccc5f582b", "doctype":"json", "version":"2.1", "keyfrom":"fanyi.web", "action":"FY_BY_REALTIME", "typoResult":"false" &#125; data=bytes(parse.urlencode(formdata),encoding='utf-8') #利用Request将headers，dict，data整合成一个对象传入urlopen req = request.Request(url,data,headers,method='POST') response=request.urlopen(req) info = response.read().decode('utf-8') strRule = re.compile('"tgt":(.*?)&#125;') info2 = strRule.findall(info) for i in info2: i = i.replace('"',"") return info2[0]def info(object, spacing=15, collapse=0): """ Print methods and doc strings. Take module, class, dictionary, or string. """ # 遍历一遍object对象，把里面的可以被调用的方法提取出来 methodList = [method for method in dir(object) if callable(getattr(object, method))] # 把要提取出来的方法以更好看的,多行变单行 #collapse可以控制打印的信息是否换行 #collapse = 1,并行 #collapse = 0,保持原来的显示 processFunc = collapse and (lambda s:" ".join(s.split())) or (lambda s:s) # 让左端打印的是方法名称，右端打印的是方法的doc名称 #print('\n'.join(["%s %s"%(str(method.ljust(spacing)), # processFunc(str(getattr(object, method).__doc__))) # for method in methodList])) print('\n'.join(["%s %s"%(str(method.ljust(spacing)), processFunc(getTInfo(str(getattr(object, method).__doc__)))) for method in methodList]))# 测试import osinfo(os.path)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F15%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
    <content type="text"><![CDATA[正则表达式 动机1.处理文本成为计算机常见工作之一2.对文本内容的搜索提取是一项比较复杂困难的工作3.为了快速方便处理上述问题，正则表达式技术诞生，逐渐被发展为一个被众多语言使用的独立技术定义：即高级文本匹配模式，提供了搜索，替代等功能，本质是由一系列特殊符号和字符组成的字串 这个字串即是正则表达式，这个表达式描述了字符和字符的重复行为，可以匹配一类特征的字符串 目标：1.熟练使用正则表达式符号2.正确的组合和理解一般的正则表达式3.能够使用python操作正则表达式 正则表达式的特点1.方便进行检索和修改2.支持语言众多3.灵活多样4.mongo正则类型，django等框架作为url匹配，爬虫 正则表达式的使用python—&gt;re模块 处理正则表达式 re.findall(pattern,string)功能：使用正则表达式匹配字符串参数：pattern 正则表达式 string 目标字符串返回值：一个列表，匹配到的所有内容 元字符（即正则表达式中有特殊含义的符号） 1.普通字符元字符：abc匹配规则：匹配响应的普通字符 2.或元字符：|匹配规则：匹配|两边任意一个正则表达式符合的情况| 两侧不要有没用的空格 3.匹配单一字符元字符：.匹配规则：匹配除了换行之外的任意字符f.o –&gt; foo fao f#o … 4.匹配开始位置元字符： ^匹配规则：匹配一个字符串的开始位置 5.匹配结束位置元字符：$匹配规则：匹配目标字符串的结束位置py$ —&gt; hello.py 6.匹配重复元字符：*匹配规则：匹配前面的正则表达式重复0次或多次 7.匹配重复元字符：+匹配规则：匹配前面的正则表达式重复1次或多次ab+ —&gt;ab abb abbb … 8.匹配重复元字符：？匹配规则：匹配前面的正则表达式重复0次或1次ab？ —&gt;a,ab 9.匹配重复元字符：{n}匹配规则：匹配指定的重复次数ab{3}—&gt;abbb 10.匹配重复元字符：{m,n}匹配规则：匹配前面的正则表达式m次到n次ab{3,5}—&gt; abbb,abbbb,abbbbb 11.匹配字符集合元字符：[]匹配规则：匹配中括号内的任意一个字符[abcd1] a b c d 1[a-z][A-Z][0-9][123a-zA-Z] 12.匹配字符集合元字符：[^…]匹配规则：匹配除指定字符集之外的任意字符 13.匹配任意(非)数字字符元字符：\d \D匹配规则：\d 匹配任意数字字符 [0-9] \D 匹配任意非数字字符 [^0-9] 14.匹配（非）普通字符（普通字符：数字，字母，下划线）元字符：\w \W匹配规则：\w 匹配任意一个普通字符 [_0-9a-zA-Z] \W 匹配任意一个非普通字符 [^_0-9a-zA-Z] 15.匹配（非）空字符元字符：\s \S匹配规则：\s 匹配任意一个空字符 \S 匹配任意一个非空字符空字符：[ \n\t\r] 16.匹配起止位置元字符： \A \Z匹配规则：\A 匹配开始位置 ^ \Z 匹配结束位置 $绝对匹配 \Aabc\Z —&gt; abc 只能是abc 17.匹配(非)单词边界位置元字符：\b \B匹配规则：\b 匹配单词边界 \B 匹配非单词边界 单词边界：数字字母下划线和其他字符的交界位置为单词的边界 元字符总结：匹配单个字符：a . \d \D \w \W \s \S [] [^…]匹配重复性：* + ？ {N} {m,n}匹配某个位置：^ $ \A \Z \b \B其他：| () \ re.findall(‘^\d[0-9a-zA-Z]{7,9}’,’1caijie2b’) 正则表达式特殊符号. * ？ $ ‘’ “” [] {}() \ ^如果想匹配特殊符号则加转义 贪婪和非贪婪 正则表达式默认的重复匹配模式：贪婪模式尽可能多的向后匹配 ？ {m,n} 这四种情况下会产生贪婪模式非贪婪模式：尽可能少的匹配内容，满足正则表达式含义即可 贪婪—&gt;非贪婪 *？ +？ ？？ {m,n}？ 正则表达式分组使用（）可以为一个正则表达式建立一个子组，子组可以看做内部的整体 abcd(ef)—&gt; abcdef 子组的作用1.增加子组后对正则表达式整体的匹配内容没有影响2.子组可以改变重复元字符的重复行为3.子组在某些操作中可以对子组匹配内容单独提取子组的注意事项1.每个正则表达式可以有多个子组，由外到内，由左到右为第一，第二…子组2.子组通常不要交叉 捕获组和非捕获组（命名组和非命名组）子组命名格式（？Pabc）很多编程接口可以直接通过名字获取子组匹配内容捕获组中的正则表达式可以通过名字重复调用 调用：（？P=name）(?Pab)cdef(?P=aa)—&gt;abcdefab re模块 compile(pattern,flags=0)功能：获取正则表达式对象参数：pattern：正则表达式 falgs：功能标志位，提供更丰富的匹配返回值：正则表达式对象 re模块和compile对象均有的函数 obj.findall(string,pos,endpos)功能：通过正则表达式匹配字符串参数：string 目标字符串 pos 目标字符串的匹配开始位置 posend 目标字符串的匹配结束位置返回值：匹配到的所有内容以列表返回如果正则表达式有子组的话则只显示子组匹配内容 obj.split(string)功能：按照正则表达式切割字符串参数：目标字符串返回值：切割后的内容，以列表的形式返回 obj.sub(replaceStr，string，count)功能：替换正则表达式匹配的内容参数：replaceStr 要替换的内容 string 目标字符串 count 最多替换几处返回值：返回替换后的字符串 obj.subn(repl,string,count)功能：替换正则表达式匹配的内容参数：replaceStr 要替换的内容 string 目标字符串 count 最多替换几处返回值：返回替换后的字符串和实际替换的个数 obj.finditer()功能：使用正则表达式匹配目标内容参数：目标字符串返回值：迭代对象，迭代的每个对象为一个match对象 re.match(pattern,string)功能：匹配一个字符串的开头参数：目标字符串返回值：迭代对象，迭代的每个对象为一个match对象 没有匹配返回None re.search(pattern,string)功能：匹配一个字符串参数：目标字符串返回值：如果匹配返回match obj 没有匹配返回None match 只能匹配字符串的开头，search可以匹配任意字符位置，但是也只能匹配一次match对象调用其他属性时往往需要try异常处理 re.fullmatch()要求目标字符串完全匹配 compile对象属性方法（re模块没有） flags：标志位pattern：正则表达式groupindex：捕获组groups：多少个子组 match对象属性方法 pos:目标字符串的开头位置endpos：目标字符串的结束位置re:正则表达式对象lastgroup:最后一组的名字lastindex: 最后一组是第几组string:目标字符串 start():匹配到内容的开始位置end(): 匹配到内容的结束位置span():匹配到内容的起止位置 group(n):功能：获取match对象匹配的内容参数：默认为0，表示获取正则整体的匹配内容 如果传入大于0的整数则表示获取对应子组匹配内容返回值：返回匹配到的内容 groups():功能：得到所有子组匹配的内容 groupdict():功能：得到所有捕获组匹配的内容]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程间通信方式]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F13%2F%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[进程间通信 磁盘交互：1.速度慢 2.不安全 socket 本地套接字 管道 消息队列 共享内存 信号 信号量 套接字 管道通信在内存中开辟一块空间，对多个进程可见，通过管道，多进程进行通信 multiprocessing–&gt;pipe fd1,fd2=Pipe(duplex=True)功能：创建一个管道参数：duplex 默认为True 表示是个双向管道 设置为False则表示单向管道返回值：返回两个管道流对象，表示管道的两端 如果是双向管道则两个均可读写 如果是单向管道则fd1只能读，fd2只能写 接收消息，fd1.recv（）功能：接收消息（每次一条）参数：无返回值：接收到的消息如果管道没有消息会阻塞 发送消息，fd2.send（）功能：发送消息，可以是字符串或其他类型参数：要发送的内容如果没有接收端管道破裂 消息队列队列：先进先出 在内存中开辟队列模型，用来存放消息，任何拥有队列的进程都可以存取消息 队列的创建 multiprocessing Queue Queue（maxsize=0） 功能：创建一个消息队列 在Python中有标准模块queue，队列模型，和进程无关 参数：maxsize默认为0 表示队列可存放消息由内存而定 &gt;0 表示队列最多存放多少条消息 q.put（） 功能：向队列中存放消息 参数：要存的消息（字符串，整数，队列） 当队列满时会阻塞 q.full()判断队列是否为满，如果满返回True q.get() 功能：向队列中取出消息 返回值：取出的消息 当队列为空时会阻塞 q.empty() 判断队列是否为空，空返回True q.qsize() 得到当前队列中消息的个数 q.close() 关闭队列 put get 中均有可选参数block和timeout block默认为True表示阻塞函数，如果设置为False则不阻塞 timeout block为True时设置超时时间 共享内存（效率高） 在内存中开辟一段空间，存储数据，对多个进程可见 每次写入共享内存的数据会覆盖之前的内容 由于对内存格式化较少，所以存取速度快 from multiprocessing import Value,Array obj=Value(ctype,obj) 功能：开辟共享内存空间 参数：ctype str 要转变的c类型（对照ctype表） obj 写入共享内存的初始值 返回值：返回一个共享内存对象 obj.value 即可得到共享内存中的值 obj=Array(ctype,obj) 功能：开辟共享内存空间 参数：ctype 要转换的类型 obj 存入到共享内存中的数据 是一个列表，要求列表中数据类型一致 是一个整数，表示开辟一个多大的空间 返回一个共享内存对象 信号 一个进程向另一个进程通过信号传递某种信息 kill -l 查看信号kill -signame PID 给PID发送一个信号 关于信号： 信号名称：系统定义，信号的名字信号的含义：系统定义，信号的作用信号的默认处理方法：系统定义，信号给接收进程带来的行为，一般有终止，暂停，忽略 Python如何操作信号 发送 os.kill(pid,sig) 功能：向一个进程发送一个信号 参数：pid:要发送信号的进程pid号 sig:要发送的信号 signal.alarm(sec) 功能：向自身发送一个时钟信号 SIGALRM 参数：sec时钟秒数 信号属于异步通讯方式，信号的发送不会影响进程的持续执行 一个进程中只能同时有一个时钟，后面的时钟时间会覆盖前面的 处理： signal.pause() 功能：阻塞等待一个信号的发生 signal.signal(signum,handler) 功能：处理一个信号 参数：signum：要处理的信号 handler：对该信号的处理方法 SIG_DFL：采取原信号的默认方法处理 SIG_IGN：忽略接收到的信号 func： 回调函数，自定义的方法处理 signal函数是一个异步处理信号函数，只要执行，在进程中就会按照指定方法处理信号 signal不能处理SIGSTOP，SIGKILL信号 func格式要求： def func（sig，frame）： ... sig:接收到的信号 frame：信号对象，可以操作信号的属性 信号量：给定一定的信号量，对多个进程可见，并且多个进程均可操作，进程根据信号量 的多少，可以有不同的行为]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程池]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F12%2F%E8%BF%9B%E7%A8%8B%E6%B1%A0.html</url>
    <content type="text"><![CDATA[进程池在需要频繁的创建删除较多进程的情况下，导致计算机资源消耗过多 进程池如何处理 1.创建进程池，在池内放入适量的进程2.将事件加入进程池等待队列3.使用进程池中的进程不断处理事件4.所有事件处理后，回收关闭进程池from multiprocessing import Pool Pool（）功能：创建进程池参数：precesses：指定进程池中进程数量返回值：得到进程池对象 pool.apply_async()功能：异步方式将事件放入进程池执行参数： func：要执行的事件函数 args：同Process args kwds：同Process kwargs返回值：返回一个对象，该对象可以通过get()方法得到func函数的返回值pool.close（）功能：关闭进程池，使其无法加入新事件pool.join()功能：阻塞等待进程池退出（当所有事件处理完毕后） pool.apply()用法和apply_async一样，只是需要顺序执行，一个事件结束后再执行另一个事件 pool.map(func，iter)功能：类似于内建函数map，将第二个参数的迭代数传递给第一个参数的函数执行。同时兼容了使用进程池执行返回值：返回func的返回值列表r=pool.map(func,test)–&gt; r=[] for i in test: res=pool.apply_async(fun,(i,)) r.append(res.get())]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multiprocessing模块]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F09%2Fmultiprocessing%E6%A8%A1%E5%9D%97.html</url>
    <content type="text"><![CDATA[multiprocessing模块创建进程，标准库1.需要将事件封装为函数2.使用multiprocessing提供的类创建新进程3.新的进程和对应的函数相关联，进程启动会自动执行函数，完成事件4.进程回收创建子进程类 multiprocessing.Process()功能：创建子进程参数：name:给创建的进程起一个名字 默认process-1 target：目标函数 args：元组，要给函数传递的参数 位置 kwargs：字典，要给函数传递的参数 键值 进程对象属性函数p.start()功能：启动子进程 此时进程真正创建 p.join([timeout])功能：阻塞等待回收相应的子进程参数：默认为阻塞，timeout为超时时间 p的其他属性p.name 进程名称p.pid 创建的进程的pid号p.is_alive（） Ture：进程处于活跃状态，False：进程处于终止状态 p.daemon 默认值为False表示主进程结束后不影响子进程的执行 如果设置为True则主进程执行完毕所有的子进程一同 退出 *设置必须在start（）前 *一般使用daemon=True时，不用加join *该属性并不是linux/unix系统中所说得守护进程设置 守护进程：生命周期长，随系统创建，随系统销毁 不受前端控制，后台运行 操作系统进程，或者是自动化运行进程居多 获取文件的大小size=os.path.getsize(‘file’)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[僵尸进程]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F03%2F%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[孤儿进程： 父进程先于子进程退出，此时子进程便为孤儿进程 孤儿进程会被系统指定的进程所“收养”，即该进程称为孤儿进程的新的父进程 在孤儿进程退出时，“继父”会进行处理，不会是其成为僵尸进程僵尸进程： 子进程先于父进程退出，但是父进程没有处理子进程的退出状况，子进程就会变成僵尸进程。 僵尸进程会滞留PCB的部分信息在内存中 大量的僵尸进程会消耗系统资源，所以应该尽量避免僵尸进程的产生 如何避免僵尸进程的产生 1.让父进程先退出（不好控制） 2.让父进程处理子进程的退出 使用wait或者waitpid函数 os.wait() 功能：等待子进程的退出，进行处理 参数：无 返回值：一个元组，第一个值为退出的子进程pid 第二个值为子进程退出状态 使用信号处理 os.waitpid(pid,option) 功能：处理子进程的退出 参数 pid：-1 表示等待任意的子进程退出 &gt;0 表示等待相应的pid号的子进程 option：0 表示阻塞等待 WNOHANG： 表示非阻塞等待,需要循环处理查看子进程的状态 返回值：同wait 3.创建二级子进程 父进程创建子进程后，等待子进程退出 子进程创建二级子进程后，马上退出，二级子进程成为孤儿进程 让父进程和二级子进程处理具体事件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP粘包处理方法]]></title>
    <url>%2F%2Fblog%2F2018%2F04%2F02%2FTCP%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[tcp粘包处理tcp中数据以数据流的方式发送接收，每次发送的数据间没有边界，在接收时可能造成数据的粘连即为粘包 粘包如何处理： 1.每次发送消息结束位置加标志 2.发送的消息添加结构描述 3.当连续发送时每次发送有一个短暂的延迟 sleep(0.1)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fork多进程]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F26%2Ffork%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[使用fork方法，创建多进程import os os.fork()功能：创建一个新的进程参数：无返回值：失败返回一个负数， -1 成功 0 在子进程中fork的返回值 &gt;0的正整数（新进程的PID号）在父进程中的返回值 父进程中fork之前的内容子进程同样会复制，但父子进程空间独立，fork之后的修改不会影响到对方父子进程在执行上互不影响，谁先执行，谁先执行完不确定子进程虽然复制父进程的空间，但是有自己的特性，比如自己的PID，进程PCB,进程栈空间等。 进程相关函数获取PID号os.getpid()功能：获取当前进程的PID号返回值：当前进程PID os.getppid()功能：获取当前进程父进程的PID号返回值：父进程PID 进程的退出 os._exit(status) 功能：结束一个进程参数：表示进程的结束状态，是一个整数0：表示程序正常退出1：异常退出sys.exit([status])功能：结束一个进程，抛出异常参数：传入一个正整数，表示结束状态 传入字符串，表示结束打印]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F25%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html</url>
    <content type="text"><![CDATA[什么是IO多路复用同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件，形成并发的效果 并发和并行的区别并发：多个事件同时发生，产生一个同时处理的效果并行：多个事件同时进行 多路复用之select模块import select select —&gt; win,linux,uinxpoll —&gt; linux,uinxepoll —&gt;linux,uinx r,w,x=select(rlist,wlist,xlist,[timeout])功能：监控IO事件，阻塞等待IO事件发生参数：rlist: 列表 存放我们要监控等待处理的IO 需要满足一定的条件才能够发生的事 存储在这个列表中 wlist：列表 存放我们希望主动处理的IO wlist中的内容会立即返回，处理 比如send发送，可以自主处理 不经常使用，容易被忽略 xlist：列表 存放如果发生异常需要我们处理的 监控异常发生的列表 timeout：数字 表示超时检测 默认一直阻塞 超过这个时间后结束阻塞 当任意一个事件准备就绪后，返回返回值：r:列表 rlist当中准备就绪的IO w:列表 wlist中准备就绪的IO x:列表 xlist中准备就绪的IO IO多路复用注意点：1.在处理IO过程中不应该发生死循环（某个IO单独占有服务器） 2.IO多路复用是单进程程序，是一个并发程序 3.IO多路复用有较高的IO执行效率 多路复用之poll模块1.创建poll对象 p=select.poll() 2.加入关注的IO p.register(s) p.unregister(s) 从关注IO中删除 3.使用poll函数监控 events=p.poll() 功能：阻塞函数，直到任意一个监控的对象准备就绪 返回值：event[(fileno,event),(),()] fileno:准备就绪事件的fileno event：用来判断一个事件是否准备就绪 4.处理发生的IO事件 poll io事件 POLLIN POLLOUT POLLUP POLLERR POLLPRI POLLVAL rlist wlist 断开连接 xlist 紧急处理 无效数据 多路复用之epoll模块效率上比poll和select稍微高点 内核找到就绪io后直接返回，不用在应用层遍历一遍只能用于linux，unix支持边缘触发 select poll只支持水平触发 水平触发： 每隔一段时间都访问一次应用层，通知事件就绪，不阻塞 边缘触发： 一次没有处理后继续阻塞，当有新的事件就绪后，一起返回]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP应用之HTTP传输]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F23%2FTCP%E5%BA%94%E7%94%A8%E4%B9%8BHTTP%E4%BC%A0%E8%BE%93.html</url>
    <content type="text"><![CDATA[TCP应用之http传输通途：网站中网页的传输和数据传输 也可用作基于http协议的编程传输数据特点：应用层协议，传输层是用tcp连接 简单，灵活，接口使用方便 几乎支持所有的数据类型 是无状态的协议（通信过程中不记录客户端的访问状态） 比如登录京东，登录一个网页后再打开另一个网页不许登录，这种状态的记录不是由http协议规定的 是由浏览器私自规定的cookies记录的，为了方便访问记录的用户状态，http协议本身不会做任何的记录 持续连接 http1.1版本 做的修改 在http1.0之前是无连接，每次访问后断开，之后从新连接 之后做的修改后为持续连接 详见：《http图解》 请求（request）格式：12345678910111213141516171819请求行：确定具体的请求类型请求头：对请求内容的信息描述空行请求正文：具体请求参数请求行：GTE /index.html HTTP/1.1 请求方法 请求资源 协议版本请求方法：GET：获取网络资源 POST：提交一定的附加数据得到返回结果 HEAD：只获取响应的头信息 PUT：获取服务器的资源 DELETE：删除服务器资源 TRACE：用于测试 CONNECT：保留方法 OPTIONS：请求获取服务器性能和信息请求体： get请求---》get参数 &amp;a=1&amp;b=2 post请求---》post提交的内容 响应（response）格式：12345678910111213141516171819202122响应行：反馈响应的情况响应头：对响应的具体描述空行响应体：具体返回给用户的内容响应行： HTTP/1.1 200 OK 协议版本 响应码 信息1xx：提示信息，表示请求已经接受，正在处理2xx：请求响应成功3xx：重定向，完成任务需要其他操作4xx：请求资源不存在，客户端错误5xx：服务端错误200：成功401：没有访问权限404：资源不存在500：服务器发生未知错误503：服务器暂时无法执行响应头格式同请求头响应体：具体内容]]></content>
      <categories>
        <category>tcp</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建简单TCP连接]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F23%2F%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95TCP%E8%BF%9E%E6%8E%A5.html</url>
    <content type="text"><![CDATA[TCP服务端 from socket import *１．创建套接字socket(socket_family=AF_INET, socket_type=SOCK_STREAM, proto=0)功能：创建套接字参数：socket_family: 选择地址簇种类 AF_INET socket_type: 套接字类型SOCK_STREAM 流式套接字 SOCK_DGRAM 数据报套接字 proto: 子协议类型默认为０返回值：返回创建的套接字２．绑定IP和端口号 sockfd.bind()功能： 绑定IP和端口参数： 是一个元组，第一项是字符串形式的IP 第二项是端口号 （’192,168,1,1’,8888) ３．让套接字具有监听功能sockfd.listen(n)功能：使套接字变为监听套接字，同时创建监听队列参数：n监听队列大小 ４．等待客户端连接sockfd.accept()功能：阻塞等待客户端连接返回值：第一个：返回一个新的套接字用来和客户端同信 第二个：返回连接的客户端的地址 ５．消息的收发recv(buffer)功能：接受消息参数：一次接受消息的大小 字节返回值：返回接收到的内容 send(data)功能：发送消息参数：发送的内容（发送byte格式的字节）返回值：发送了多少个字节当没有接收端的时候send操作会导致 broken pipe６．关闭套接字close()功能：关闭套接字 TCP客户端 １．创建流式套接字２．发起连接请求connect()功能：发起连接参数：一个元组 第一个元素： 服务器的IP 第二个元素： 服务器的port ３．收发消息４．关闭套接字 tcp_client.py123456789101112131415161718192021from socket import *#创建套接字sockfd=socket(AF_INET,SOCK_STREAM)#发起连接sockfd.connect(('127.0.0.1',9999))while True: #发送消息 msg=input('input：') sockfd.send(msg.encode()) if not msg: break #接受消息 data=sockfd.recv(1024) print(data.decode())#关闭连接sockfd.close() tcp_server.py1234567891011121314151617181920212223242526from socket import *#创建流式套接字sockfd=socket(AF_INET,SOCK_STREAM,0)#绑定IP和端口sockfd.bind(('127.0.0.1',8882))#设置为监听套接字，创建监听队列sockfd.listen(5)while True: #等待客户端连接 print('waiting for connect...') input('hello') connfd,addr=sockfd.accept() print('connect from:',addr) while True: #收发消息 data=connfd.recv(10) if not data: break print(data.decode()) connfd.send('receive your message'.encode()) #关闭套接字 connfd.close()sockfd.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析udp]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F22%2F%E6%B5%85%E6%9E%90udp.html</url>
    <content type="text"><![CDATA[udp通信 1.创建套接字sockfd=socket(AF_INET,SOCK_DGRAM) 2.绑定服务端地址ADDR=(&apos;192.188.1.2&apos;,8888) sockfd.bind(ADDR) 3.收发消息data,addr=recvfrom(buffersize) 功能：接收数据报套接字消息 参数：每次最多接收消息的大小 单位：字节 返回值：data 接收到的消息，addr 消息发送者的地址 一次接收一个数据包，如果数据包一次没有接收完则会丢失没接收的内容 sendto(data,addr) 功能：发送消息 参数：data 要发送的消息 addr 发送给某个主机的地址 返回值：发送消息的字节数 4.关闭套接字close() udp_client.py1234567891011121314151617181920212223242526272829from socket import *import sys#从命令行传入ip和端口#python3 udp_server.py 127.0.0.1 8888if len(sys.argv)&lt;3: print(''' argv is error input as python3 udp_server.py 127.0.0.1 8888 ''')host = sys.argv[1]port = int(sys.argv[2])addr = (host,port)buffersize=1024#创建数据报套接字sockfd=socket(AF_INET,SOCK_DGRAM)while True: data = input('消息&gt;&gt;') #回车退出 if not data: break sockfd.sendto(data.encode(),addr) data,addr=sockfd.recvfrom(buffersize) print('从服务器接收到：',data.decode())sockfd.close() udp_server.py1234567891011121314151617181920212223242526272829303132from socket import *import sysfrom time import ctime#从命令行传入ip和端口#python3 udp_server.py 127.0.0.1 8888if len(sys.argv)&lt;3: print(''' argv is error input as python3 udp_server.py 127.0.0.1 8888 ''')host = sys.argv[1]port = int(sys.argv[2])addr = (host,port)buffersize=1#创建数据报套接字sockfd=socket(AF_INET,SOCK_DGRAM)#绑定地址sockfd.bind(addr)#收发消息while True: data,addr=sockfd.recvfrom(buffersize) print('recv from %s:%s'%(addr,data.decode())) sockfd.sendto\ (('[%s] 接收到消息'%ctime()).encode(),addr)#关闭sockfd.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__init__()方法和__new__()方法的区别]]></title>
    <url>%2F%2Fblog%2F2018%2F03%2F21%2Finit-%E6%96%B9%E6%B3%95%E5%92%8C-new-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html</url>
    <content type="text"><![CDATA[下面先通过一段代码看看这两个方法的调用顺序：12345678910#!/usr/bin/env pythonclass A(object): def __init__(self,*args,**kwargs): print "init &amp;&amp;&amp;&amp; %s" % self.__class__ def __new__(cls,*args,**kwargs): print "new &amp;&amp;&amp;&amp; %s" % cls return object.__new__(cls,*args,**kwargs)a=A() 输出结果为：12new &amp;&amp;&amp;&amp; &lt;class '__main__.A'&gt;init &amp;&amp;&amp;&amp; &lt;class '__main__.A'&gt; 如果把最后一行的return代码屏蔽掉，输出结果为：1new &amp;&amp;&amp;&amp;&lt;class '__main__.A'&gt; 此处为什么会只输出一行，请参考文章[Python中new()方法的使用和实例化](http://blog.csdn.net/four_infinite/article/details/52798919) 一般来说，”init”和”new”函数都会有下面的形式：12345def __init__(self, *args, **kwargs): # func_suitedef __new__(cls, *args, **kwargs): # func_suite 对于”new”和”init”可以概括为：“new”方法在Python中是真正的构造方法（创建并返回实例），通过这个方法可以产生一个”cls”对应的实例对象，所以说”new”方法一定要有返回。对于”init”方法，是一个初始化的方法，”self”代表由类产生出来的实例对象，”init”将对这个对象进行相应的初始化操作。 重写new如果（新式）类中没有重写”new”方法，Python默认是调用该类的直接父类的”new”方法来构造该类的实例，如果该类的父类也没有重写”new”，那么将一直按照同样的规则追溯至object的”new”方法，因为object是所有新式类的基类。 而如果新式类中重写了”new”方法，那么可以选择任意一个其他的新式类（必须是新式类，只有新式类有”new”，因为所有新式类都是从object派生）的”new”方法来创建实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环。 看一段例子代码：1234567891011121314151617181920212223242526272829303132333435363738#!/usr/bin/env python#coding:utf-8class Foo(object): def __new__(cls,*args,**kwargs): obj = object.__new__(cls,*args,**kwargs) #这里的object.__new__(cls,*args,**kwargs)等价于 # super(Foo,cls).__new__(cls,*args,**kwargs) # object.__new__(Foo,*args,**kwargs) # Bar.__new__(cls,*args,**kwargs) # Student.__new__(cls,*args,**kwargs),即使Student和 # Foo没有关系也是允许的，因为Student是由object派生的新类 # 在任何新式类中，不能调用自身的__new__来创建实例，因为这会 # 造成死循环，所以要避免出现这样的语法 Foo.__new__(cls,*args,**kwargs) # 或者 cls.__new__(cls,*args,**kwargs) print "Calling __new__ for %s" % obj.__class__ return objclass Bar(Foo): def __new__(cls,*args,**kwargs): obj = object.__new__(cls,*args,**kwargs) print "Calling __new__ for %s" % obj.__class__ return objclass Student(object): #Student没有__new__方法，那么会自动调用父类的__new__方法来 #创建实例，即会自动调用object.__new__(cls) passclass Car(object): def __new__(cls,*args,**kwargs): obj = object.__new__(Bar,*args,**kwargs) print "Calling __new__ for %s" % obj.__class__ return objfoo = Foo()bar = Bar()car = Car() 运行结果是：123Calling __new__ for &lt;class '__main__.Foo'&gt;Calling __new__ for &lt;class '__main__.Bar'&gt;Calling __new__ for &lt;class '__main__.Bar'&gt; _init_的调用 “new”决定是否要使用该类的”init”方法，因为”new” 可以调用其他类的构造方法或者直接返回别的类创建的对象来作为本类的实例。通常来说，新式类开始实例化时，”new”方法会返回cls（cls指代当前类）的实例，然后调用该类的”init”方法作为初始化方法，该方法接收这个实例（即self）作为自己的第一个参数，然后依次传入”new”方法中接收的位置参数和命名参数。但是，如果”new”没有返回cls（即当前类）的实例，那么当前类的”init”方法是不会被调用的。看下面的例子： 123456789101112131415161718192021#!/usr/bin/env pythonclass A(object): def __init__(self,*args,**kwargs): print "calling __init__ from %s" % self.__class__ def __new__(cls,*args,**kwargs): obj = object.__new__(cls,*args,**kwargs) print "calling __new__ from %s" % obj.__class__ return objclass B(A): def __init__(self,*args,**kwargs): print "calling __init__ from %s" % self.__class__ def __new__(cls,*args,**kwargs): obj = object.__new__(A,*args,**kwargs) print "calling __new__ from %s" % obj.__class__ return objb=B()print type(b) 代码中，在B的”new”方法中，通过”obj = object.new(A, args, *kwargs)”创建了一个A的实例，在这种情况下，B的”init”函数就不会被调用到。运行结果是：12calling __new__ from &lt;class '__main__.A'&gt;&lt;class '__main__.A'&gt; 派生不可变类型关于”new”方法还有一个重要的用途就是用来派生不可变类型例如，python中的float类型是一个不可变类型，如果想要从float中派生出一个子类，就可以使用”new”方法：12345678910#!/usr/bin/env pythonclass Round2Float(float): def __new__(cls,num): num = round(num,2) obj = float.__new__(Round2Float,num) return objf=Round2Float(4.324599)print f 这段程序从float类中派生出了一个Round2Float类，这个类的作用就是保留小数点后两位的浮点数。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018 Pycharmm 激活方法]]></title>
    <url>%2F%2Fblog%2F2018%2F02%2F01%2F2018-Pycharmm-%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[1、将”0.0.0.0 account.jetbrains.com”添加到hosts文件中 2、打开http://idea.lanyus.com 3、获取激活码，粘贴到第二个选项中 亲测可用。]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之反射]]></title>
    <url>%2F%2Fblog%2F2018%2F01%2F08%2Fpython%E4%B9%8B%E5%8F%8D%E5%B0%84.html</url>
    <content type="text"><![CDATA[什么是反射？１、有时我们要访问某个变量或是方法时并不知道到底有没有这个变量或方法，所以就要做些判断。判断是否存在字符串对应的变量及方法。２、我们知道访问变量时是不能加引号的，否则会被当成字符串处理。如果要通过字符串找到对应的变量，那该怎么办呢反射就是用于解决上面两个问题而产生的，所谓反射，按我的理解就是反过来告诉我字符串是什么，是变量or方法 python中访问类或对象的成员有三种方法如下所示 obj 为对象 var为变量 func为函数123１、obj.var 或 obj.func()２、obj.__dict__['var']３、getattr(obj,'var') 反射有４个方法 getattr() hasattr() setattr() delattr() 举例子如下，一目了然123456789101112131415161718192021222324class A(object): gvar = 'min' def __init__(self,name,male): self.name = name self.male = male def func1(self): print "func1 :my name is %s" % self.name def func2(self): print "func2 :I'm a %s" % self.male##实例化对象obj = A('min','girl')hasattr(obj,'gvar')hasattr(obj,'func1')getattr(obj,'gvar')getattr(obj,'name')getattr(obj,'func1')getattr(obj,'func2')()setattr(obj,'gvar','ben')getattr(obj,'gvar')delattr(obj,'gvar')##python中一切事物都是对象，故其实上面的obj也是可以是类名，模块名getattr(A,'func2')hasattr(A,'func1') 当某个字符串就是模块名时，我们导入模块时可以用以下方法导入mymodule = import(var) #这个就相当于导入模块var.py了 导入后，你可以在你的代码中用mymodule.*来调用该模块下的任意方法 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; class A(object):... gvar = 'min'... def __init__(self,name,male):... self.name = name... self.male = male... def func1(self):... print "func1 :my name is %s" % self.name... def func2(self):... print "func2 :I'm a %s" % self.male... &gt;&gt;&gt; ##实例化对象... obj = A('min','girl')&gt;&gt;&gt; hasattr(obj,'gvar')True&gt;&gt;&gt; hasattr(obj,'func1')True&gt;&gt;&gt; getattr(obj,'gvar')'min'&gt;&gt;&gt; getattr(obj,'name')'min'&gt;&gt;&gt; getattr(obj,'func1')&lt;bound method A.func1 of &lt;__main__.A object at 0x7f7b89f99a50&gt;&gt;&gt;&gt;&gt; getattr(obj,'func2')()func2 :I'm a girl&gt;&gt;&gt; setattr(obj,'gvar','ben')&gt;&gt;&gt; getattr(obj,'gvar')'ben'&gt;&gt;&gt; delattr(obj,'gvar')&gt;&gt;&gt; ##python中一切事物都是对象，故其实上面的obj也是可以是类名，模块名... getattr(A,'func2')&lt;unbound method A.func2&gt;&gt;&gt;&gt; hasattr(A,'func1')True]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[format函数用法详解]]></title>
    <url>%2F%2Fblog%2F2018%2F01%2F02%2Fformat%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[python之字符串格式化(format)用法： 它通过{}和:来代替传统%方式 1、使用位置参数要点：从以下例子可以看出位置参数不受顺序约束，且可以为{},只要format里有相对应的参数值即可,参数索引从0开，传入位置参数列表可用*列表 123456789&gt;&gt;&gt; li = ['hoho',18]&gt;&gt;&gt; 'my name is &#123;&#125; ,age &#123;&#125;'.format('hoho',18)'my name is hoho ,age 18'&gt;&gt;&gt; 'my name is &#123;1&#125; ,age &#123;0&#125;'.format(10,'hoho')'my name is hoho ,age 10'&gt;&gt;&gt; 'my name is &#123;1&#125; ,age &#123;0&#125; &#123;1&#125;'.format(10,'hoho')'my name is hoho ,age 10 hoho'&gt;&gt;&gt; 'my name is &#123;&#125; ,age &#123;&#125;'.format(*li)'my name is hoho ,age 18' 2、 使用关键字参数要点：关键字参数值要对得上，可用字典当关键字参数传入值，字典前加**即可12345&gt;&gt;&gt; hash = &#123;'name':'hoho','age':18&#125;&gt;&gt;&gt; 'my name is &#123;name&#125;,age is &#123;age&#125;'.format(name='hoho',age=19)'my name is hoho,age is 19'&gt;&gt;&gt; 'my name is &#123;name&#125;,age is &#123;age&#125;'.format(**hash)'my name is hoho,age is 18' 3、填充与格式化:[填充字符][对齐方式 &lt;^&gt;][宽度]123456&gt;&gt;&gt; '&#123;0:*&gt;10&#125;'.format(10) ##右对齐'********10'&gt;&gt;&gt; '&#123;0:*&lt;10&#125;'.format(10) ##左对齐'10********'&gt;&gt;&gt; '&#123;0:*^10&#125;'.format(10) ##居中对齐'****10****' 4、精度与进制12345678910&gt;&gt;&gt; '&#123;0:.2f&#125;'.format(1/3)'0.33'&gt;&gt;&gt; '&#123;0:b&#125;'.format(10) #二进制'1010'&gt;&gt;&gt; '&#123;0:o&#125;'.format(10) #八进制'12'&gt;&gt;&gt; '&#123;0:x&#125;'.format(10) #16进制'a'&gt;&gt;&gt; '&#123;:,&#125;'.format(12369132698) #千分位格式化'12,369,132,698' 5、使用索引1234&gt;&gt;&gt; li['hoho', 18]&gt;&gt;&gt; 'name is &#123;0[0]&#125; age is &#123;0[1]&#125;'.format(li)'name is hoho age is 18]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用yum来下载RPM包而不进行安装]]></title>
    <url>%2F%2Fblog%2F2017%2F07%2F10%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8yum%E6%9D%A5%E4%B8%8B%E8%BD%BDRPM%E5%8C%85%E8%80%8C%E4%B8%8D%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[方法一:yumyum命令本身就可以用来下载一个RPM包，标准的yum命令提供了–downloadonly(只下载)的选项来达到这个目的。1$ sudo yum install --downloadonly &lt;package-name&gt; 默认情况下，一个下载的RPM包会保存在下面的目录中:1/var/cache/yum/x86_64/[centos/fedora-version]/[repository]/packages 以上的[repository]表示下载包的来源仓库的名称(例如：base、fedora、updates) 如果你想要将一个包下载到一个指定的目录(如/tmp)：1$ sudo yum install --downloadonly --downloaddir=/tmp &lt;package-name&gt; 注意，如果下载的包包含了任何没有满足的依赖关系，yum将会把所有的依赖关系包下载，但是都不会被安装。 另外一个重要的事情是，在CentOS/RHEL 6或更早期的版本中，你需要安装一个单独yum插件(名称为 yum-plugin-downloadonly)才能使用–downloadonly命令选项：1$ sudo yum install yum-plugin-downloadonly 如果没有该插件，你会在使用yum时得到以下错误：1Command line error: no such option: --downloadonly 方法二: Yumdownloader另外一个下载RPM包的方法就是通过一个专门的包下载工具–yumdownloader。 这个工具是yum工具包(包含了用来进行yum包管理的帮助工具套件)的子集。1$ sudo yum install yum-utils 下载一个RPM包：1$ sudo yumdownloader &lt;package-name&gt; 下载的包会被保存在当前目录中。你需要使用root权限，因为yumdownloader会在下载过程中更新包索引文件。与yum命令不同的是，任何依赖包不会被下载。 http://ask.xmodulo.com/yum-download-rpm-package.html]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的读方法]]></title>
    <url>%2F%2Fblog%2F2017%2F06%2F23%2Fpython%E4%B8%AD%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[我们谈到“文本处理”时，我们通常是指处理的内容。Python 将文本文件的内容读入可以操作的字符串变量非常容易。文件对象提供了三个“读”方法： .read()、.readline() 和 .readlines()。每种方法可以接受一个变量以限制每次读取的数据量，但它们通常不使用变量。 .read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而 .read() 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。.readline() 和 .readlines() 非常相似。它们都在类似于以下的结构中使用：Python .readlines() 示例1234567891011 fh = open( 'c:\\autoexec.bat') for line in fh.readlines(): print line.readline() 和 .readlines()之间的差异是后者一次读取整个文件，象 .read()一样。 .readlines()自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for... in ... 结构进行处理。 另一方面，.readline()每次只读取一行，通常比 .readlines()慢得多。 仅当没有足够内存可以一次读取整个文件时，才应该使用.readline()。 写：writeline()是输出后换行，下次写会在下一行写。write()是输出后光标在行末不会换行，下次写会接着这行写 123456789101112通过readline输出，对于比较大的文件，这种占用内存比较小。 #coding:utf-8 f = open('poem.txt','r') result = list() for line in open('poem.txt'): line = f.readline() print line result.append(line) print result f.close() open('result-readline.txt', 'w').write('%s' % '\n'.join(result)) 12345678910111213141516#coding:utf-8 '''''cdays-4-exercise-6.py 文件基本操作 @note: 文件读取写入, 列表排序, 字符串操作 @see: 字符串各方法可参考hekp(str)或Python在线文档http://docs.python.org/lib/string-methods.html ''' f = open('cdays-4-test.txt', 'r') #以读方式打开文件 result = list() for line in f.readlines(): #依次读取每行 line = line.strip() #去掉每行头尾空白 if not len(line) or line.startswith('#'): #判断是否是空行或注释行 continue #是的话，跳过不处理 result.append(line) #保存 result.sort() #排序结果 print result open('cdays-4-result.txt', 'w').write('%s' % '\n'.join(result)) #保存入结果文件]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django—setting.py配置]]></title>
    <url>%2F%2Fblog%2F2017%2F06%2F15%2FDjango%E2%80%94setting-py%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[官方文档： https://docs.djangoproject.com/en/1.7/topics/settings/ https://docs.djangoproject.com/en/1.7/ref/settings/ setting.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334 这个文件包含了所有有关这个Django项目的配置信息，均大写： TEMPLATE_DIRS , DATABASE_NAME , 等. 最重要的设置是 ROOT_URLCONF，它将作为 URLconf 告诉 Django 在这个站点中那些 Python的模块将被用到。 使用 Django 时, 你必须告诉它你使用的是哪个 settings . 要做到这一点，使用环境变量DJANGO_SETTINGS_MODULE.默认 settings 如果不需要, Django settings 文件可以不必定义任何 settings. 因为每个设置都有默认值. 这些默认值定义在django/conf/global_settings.py.使用 settings 的法则:从 global_settings.py 载入默认设置. 从指定的 settings 文件载入用户设置, 需要时覆盖掉默认设置.注意一个用户 settings 文件，不必导入 global_settings, 这是多余的.查看你改变了哪些设置有一个简单的办法可以查看你修改了哪些设置.命令 python manage.py diffsettings 显示当前 settings 文件与Django 默认设置的不同之处.在你的代码中使用 settings通过从模块 django.conf.settings 导入你需要的变量, 你的代码可以访问这个变量. 例子:from django.conf.settings import DEBUGif DEBUG: # Do something注意一定 不要 从 global_settings 或你自己的 settings 模块导入设置变量到你的代码. django.conf.settings 概括了默认设置和站点自定义设置的概念,它提供了一个统一的接口用于用户代码访问, 也降低了用户代码与用户设置的耦合程度.在运行时修改 settings 不应该在程序运行时修改 settings. 举例来说, 不要在一个 view 中做这样的事: from django.conf.settings import DEBUG DEBUG = True # Don't do this! 你只应该在你的 settings 文件中设置 settings, 记住,这是原则.安全性由于 settings 文件包含敏感信息,象数据库密码等.你应该非常小心的设置它的访问权限. 举例来说, 你可以只允许你和 WEB 服务器用户阅读该文件.在一个共享主机环境时,这一点格外重要.可用选项下面是所有可用选项的列表及它们的默认值(按字母顺序排列).ABSOLUTE_URL_OVERRIDES 默认值: &#123;&#125; (空字典)一个字典映射 "app_label.module_name" 字符串到一个函数, 该函数接受一个model对象作为参数并返回它的URL. 这是在一个安装上覆盖 get_absolute_url() 方法的一种方式. 例子:ABSOLUTE_URL_OVERRIDES =&#123; 'blogs.blogs': lambda o: "/blogs/%s/" % o.slug, 'news.stories': lambda o: "/stories/%s/%s/" % (o.pub_year, o.slug), &#125; ADMIN_FOR 默认值: () (空的tuple)用于 admin-site settings 模块, 若当前站点是 admin ,它则是一个由 settings 模块组成的 tuple (类似'foo.bar.baz' 这样的格式).admin 站点在 models, views,及 template tags 的自动内省的文档中使用该设置.ADMIN_MEDIA_PREFIX 默认值: '/media/'The URL prefix for admin media -- CSS, JavaScript and images. Make sure to use a trailing slash.ADMINS 默认值: () (空的 tuple)一个2-元素tuple的 tuple. 列出了有权接收代码错误提示的人. 当 DEBUG=False 时,一个 view 引发了异常, Django 会将详细异常信息用电子邮件的方式发送给这些人. 该tuple的每个成员应该是这种格式: (Full name, e-mail address). 例子:(('John','john@example.com'), ('Mary','mary@example.com')) ALLOWED_INCLUDE_ROOTS 默认值: () (空的 tuple)一个字符串tuple, 只有以列表中的元素为前缀的模板Django才可以以``&#123;% ssi %&#125;`` 形式访问 . 出于安全考虑, 在不应该访问时,即使是模板的作者也不能访问这些文件.举例来说, 若 ALLOWED_INCLUDE_ROOTS 是 ('/home/html', '/var/www'), 那么 &#123;% ssi /home/html/foo.txt %&#125; 可以正常工作, 不过 &#123;% ssi /etc/passwd %&#125; 却不能.APPEND_SLASH 默认值: True是否给URL添加一个结尾的斜线. 只有安装了 CommonMiddleware 之后,该选项才起作用. (参阅 middleware 文档). 参阅 PREPEND_WWW.CACHE_BACKEND默认值: 'simple://'后端使用的 cache . 参阅 cache docs.CACHE_MIDDLEWARE_KEY_PREFIX默认值: '' (空的字符串)cache 中间件使用的cache key 前缀. 参阅 cache docs.DATABASE_ENGINE默认值: 'postgresql'后端使用的数据库引擎: 'postgresql', 'mysql', 'sqlite3' 或 'ado_mssql' 中的任意一个.DATABASE_HOST默认值: '' (空的字符串)数据库所在的主机. 空的字符串意味着 localhost. SQLite 不需要该项. 如果你使用 MySQL 并且该选项的值以一个斜线 ('/') 开始, MySQL 则通过一个 Unix socket 连接到指定的 socket. 比如:DATABASE_HOST = '/var/run/mysql'如果你使用 MySQL 并且该选项的值 不是 以斜线开始, 那么该选项的值就是主机的名字.DATABASE_NAME默认值: '' (空的字符串)要使用的数据库名字. 对 SQLite, 它必须是一个数据库文件的全路径名字.DATABASE_PASSWORD默认值: '' (空的字符串)连接数据库需要的密码. SQLite 不需要该项.DATABASE_PORT默认值: '' (空的字符串)连接数据库所需的数据库端口. 空的字符串表示默认端口. SQLite 不需要该项.DATABASE_USER默认值: '' (空的字符串)连接数据库时所需要的用户名. SQLite 不需要该项.DATE_FORMAT默认值: 'N j, Y' (举例来说 Feb. 4, 2003)在 Django admin change-list 页对日期字段使用的默认日期格式, 系统中的其它部分也可能使用该格式. 参阅allowed date format strings.参阅 DATETIME_FORMAT 和 TIME_FORMAT.DATETIME_FORMAT默认值: 'N j, Y, P' (举例来说 Feb. 4, 2003, 4 p.m.)在 Django admin change-list 页对日期时间字段使用的默认日期时间格式, 系统中的其它部分也可能使用该格式. 参阅 allowed date format strings.参阅 DATE_FORMAT 和 TIME_FORMAT.DEBUG默认值: False一个开关调试模式的逻辑值DEFAULT_CHARSET默认值: 'utf-8'如果一个 MIME 类型没有人为指定, 对所有 HttpResponse 对象将应用该默认字符集. 使用DEFAULT_CONTENT_TYPE 来构建 Content-Type 头.DEFAULT_CONTENT_TYPE默认值: 'text/html'如果一个 MIME 类型没有人为指定, 对所有 HttpResponse 对象将应用该默认 content type. 使用DEFAULT_CHARSET 来构建 Content-Type 头.DEFAULT_FROM_EMAIL默认值: 'webmaster@localhost'用于发送(站点自动生成的)管理邮件的默认 e-mail 邮箱.DISALLOWED_USER_AGENTS默认值: () (空的 tuple)一个编译的正则表达式对象列表,用于表示一些用户代理字符串.这些用户代理将被禁止访问系统中的任何页面. 使用这个对付页面机器人或网络爬虫.只有安装 CommonMiddleware 后这个选项才有用(参阅 middleware 文档).EMAIL_HOST默认值: 'localhost'用来发送 e-mail 的主机. 参阅 EMAIL_PORT.EMAIL_HOST_PASSWORD默认值: '' (空的字符串)EMAIL_HOST 中定义的 SMTP 服务器使用的密码. 如果为空, Django 不会尝试进行认证.参阅 EMAIL_HOST_USER.EMAIL_HOST_USER默认值: '' (空的字符串)EMAIL_HOST 中定义的 SMTP 服务器使用的用户名. 如果为空, Django 不会尝试进行认证.参阅 EMAIL_HOST_PASSWORD.EMAIL_PORT默认值: 25EMAIL_HOST 中指定的SMTP 服务器所使用的端口号.EMAIL_SUBJECT_PREFIX默认值: '[Django] 'django.core.mail.mail_admins 或 django.core.mail.mail_managers 发送的邮件的主题前缀.ENABLE_PSYCO默认值: False如果允许 Psyco, 将使用Pscyo优化 Python 代码. 需要 Psyco 模块.IGNORABLE_404_ENDS默认值: ('mail.pl', 'mailform.pl', 'mail.cgi', 'mailform.cgi', 'favicon.ico', '.php')参阅 IGNORABLE_404_STARTS.IGNORABLE_404_STARTS默认值: ('/cgi-bin/', '/_vti_bin', '/_vti_inf')*一个字符串 tuple . 以该tuple中元素为开头的 URL 应该被 404 e-mailer 忽略. 参阅SEND_BROKEN_LINK_EMAILS 和 IGNORABLE_404_ENDS.INSTALLED_APPS默认值: () (空的 tuple)一个字符串tuple ,内容是本 Django 安装中的所有应用. 每个字符串应该是一个包含Django应用程序的Python包的路径全称, django-admin.py startapp 会自动往其中添加内容.INTERNAL_IPS默认值: () (空的 tuple)一个 ip 地址的 tuple(字符串形式), 它:当 DEBUG 为 True 时,参阅调试务注解接收 X 头(若 XViewMiddleware 已安装), (参阅 middleware 文档) JING_PATH默认值: '/usr/bin/jing'"Jing" 执行文件路径全名. Jing 是一个 RELAX NG 校验器, Django 使用它对你的 model 的 XMLField 进行验证. 参阅 http://www.thaiopensource.com/relaxng/jing.html .LANGUAGE_CODE默认值: 'en-us'表示默认语言的一个字符串. 必须是标准语言格式. 举例来说, U.S. English 就是 "en-us". 参阅internationalization docs.LANGUAGES默认值: 一个 tuple (内容为所有可用语言). 目前它的值是:LANGUAGES = ( ('bn', _('Bengali')), ('cs', _('Czech')), ('cy', _('Welsh')), ('da', _('Danish')), ('de', _('German')), ('en', _('English')), ('es', _('Spanish')), ('fr', _('French')), ('gl', _('Galician')), ('is', _('Icelandic')), ('it', _('Italian')), ('no', _('Norwegian')), ('pt-br', _('Brazilian')), ('ro', _('Romanian')), ('ru', _('Russian')), ('sk', _('Slovak')), ('sr', _('Serbian')), ('sv', _('Swedish')), ('zh-cn', _('Simplified Chinese')),)一个2-元素tuple&lt;格式为 (语言代码, 语言名称)&gt;的 tuple. 该设置用于选择可用语言.参阅internationalization docs 了解细节.*通常这个默认值就足够了.除非你打算减少提供的语言数目,否则没必要修改这个设置.MANAGERS默认值: ADMINS (不论 ADMINS 是否已经设置)一个和 ADMINS 同样格式的 tuple , 当 SEND_BROKEN_LINK_EMAILS=True 时, 这些人有权接收死链接通知信息.MEDIA_ROOT默认值: '' (空的字符串)一个绝对路径, 用于保存媒体文件. 例子: "/home/media/media.lawrence.com/" 参阅 MEDIA_URL.MEDIA_URL默认值: '' (空的字符串)处理媒体服务的URL(媒体文件来自 MEDIA_ROOT). 如: "http://media.lawrence.com"MIDDLEWARE_CLASSES 默认值:("django.contrib.sessions.middleware.SessionMiddleware", "django.contrib.auth.middleware.AuthenticationMiddleware", "django.middleware.common.CommonMiddleware", "django.middleware.doc.XViewMiddleware")一个django 用到的中间件 class 名称的 tuple. 参阅 middleware 文档.PREPEND_WWW默认值: False是否为没有 "www." 前缀的域名添加 "www." 前缀. 当且仅当安装有 CommonMiddleware 后该选项才有效. (参阅middleware 文档).参阅 APPEND_SLASH.ROOT_URLCONF默认值: Not defined一个字符串,表示你的根 URLconf 的模块名. 举例来说:"mydjangoapps.urls". 参阅 Django如何处理一个请求.SECRET_KEY默认值: '' (空的字符串)一个密码. 用于为密码哈希算法提供一个种子.将其设置为一个随机字符串 -- 越长越好. django-admin.py startproject 会自动给你创建一个.SEND_BROKEN_LINK_EMAILS默认值: False当有人从一个有效Django-powered页面访问另一个Django-powered页面时发现404错误(也就是发现一个死链接)时, 是否发送一封邮件给 MANAGERS. 当且仅当 安装有 CommonMiddleware 时该选项才有效(参阅`middleware 文档`_). 参阅 IGNORABLE_404_STARTS 和 IGNORABLE_404_ENDS.*SERVER_EMAIL默认值: 'root@localhost'用来发送错误信息的邮件地址, 比如发送给 ADMINS 和 MANAGERS 的邮件.SESSION_COOKIE_AGE默认值: 1209600 (2周, 以秒计)session cookies 的生命周期, 以秒计. 参阅 session docs.SESSION_COOKIE_DOMAIN默认值: Nonesession cookies 有效的域. 将其值设置为类似 ".lawrence.com" 这样 cookie 就可以跨域生效, 或者使用None 作为一个标准的域 cookie. 参阅 session docs.SESSION_COOKIE_NAME默认值: 'sessionid'session 使用的cookie 名字. 参阅 session docs.SESSION_SAVE_EVERY_REQUEST默认值: False是否每次请求都保存session. 参阅 session docs.SITE_ID默认值: Not defined是一个整数, 表示 django_site 表中的当前站点. 当一个数据包含多个站点数据时，你的程序可以据此 ID 访问特定站点的数据．TEMPLATE_CONTEXT_PROCESSORS默认值:("django.core.context_processors.auth","django.core.context_processors.debug","django.core.context_processors.i18n")A tuple of callables that are used to populate the context in RequestContext. These callables take a request object as their argument and return a dictionary of items to be merged into the context.TEMPLATE_DEBUG默认值: False一个布尔值,用来开关模板调试模式.若设置为 True, 如果有任何 TemplateSyntaxError,一个详细的错误报告信息页将被显示给你.这个报告包括有关的模板片断,相应的行会自动高亮.注意 Django 仅在 DEBUG 为 True 时显示这个信息页面.参阅 DEBUG.TEMPLATE_DIRS默认值: () (空的 tuple)模板源文件目录列表,按搜索顺序. 注意要使用 Unix-风格的前置斜线(即'/'), 即便是在 Windows 上.参阅 template documentation.TEMPLATE_LOADERS默认值: ('django.template.loaders.filesystem.load_template_source',)一个元素为可调用对象(字符串形式的)的 tuple. 这些对象知道如何导入 templates 从各种源中. 参阅 template documentation.TEMPLATE_STRING_IF_INVALID默认值: '' (空的字符串)输出文本, 作为一个字符串. 模板系统将会在出错 (比如说拼错了) 时使用该变量. 参阅 How invalid variables are handled.TIME_FORMAT默认值: 'P' (举例来说 4 p.m.)Django admin change-list 使用的默认时间格式. 有可能系统的其它部分也使用该格式. 参阅 allowed date format strings.参阅 DATE_FORMAT 和 DATETIME_FORMAT.TIME_ZONE默认值: 'America/Chicago' (我们可以用 'Asia/Shanghai PRC' )一个表示当前时区的字符串. 参阅 选择项列表.Django 据此设置转换所有的日期/时间 -- 并不考虑服务器的时区设置. 举例来说, 一台服务器可以服务多个Django-powered 站点,每个站点使用一个独立的时区设置.USE_ETAGS默认值: False一个布尔值.指定是否输出 "Etag" 头. 这个选项可以节省网络带宽,但损失性能. 只有安装 CommonMiddleware 后这个选项才有用(参阅 middleware 文档)创建你自己的 settings 你可以为自己的Django 应用程序创建自定义 settings. 只需要你遵守以下惯例: 设置名称全部大写. 如果某项设置是一个序列,优先使用 tuple.这完全是基于性能考虑. 不要为已经存的一个设置重新发明一个名字.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python生成图片验证码]]></title>
    <url>%2F%2Fblog%2F2017%2F05%2F16%2Fpython%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E9%AA%8C%E8%AF%81%E7%A0%81.html</url>
    <content type="text"><![CDATA[下面是一个用python PIL 生成验证码的函数。 过程是：创建一张有底色的图片、在背景上添加杂色、写上特定文字、保存图片123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: utf-8 -*-import randomimport Imageimport ImageFontimport ImageDrawimport ImageFilterdef gen_captcha(text, fnt, fnt_sz, file_name, fmt='JPEG'): # 随机生成背景色 fgcolor = random.randint(0,0xffff00) bgcolor = fgcolor ^ 0xffffff # 生成文字 font = ImageFont.truetype(fnt,fnt_sz) dim = font.getsize(text) im = Image.new('RGB', (dim[0]+5,dim[1]+5), bgcolor) d = ImageDraw.Draw(im) x, y = im.size r = random.randint # 给背景添加杂色 for num in range(100): d.rectangle((r(0,x), r(0,y), r(0,x), r(0,y)), fill=r(0, 0xffffff)) # 添加文字 d.text((3,3), text, font=font, fill=fgcolor) im = im.filter(ImageFilter.EDGE_ENHANCE_MORE) im.save(file_name, format=fmt)def gen_random_word(wordLen=6): allowedChars = "abcdefghijklmnopqrstuvwzyzABCDEFGHIJKLMNOPQRSTUVWZYZ0123456789" word = "" for i in range(0, wordLen): word = word + allowedChars[random.randint(0,0xffffff) % len(allowedChars)] return wordif __name__ == '__main__': word = gen_random_word() print word gen_captcha(word.strip(), 'porkys.ttf', 65, "test.jpg") 进阶使用一般情况不会要求填写验证码，避免影响用户体验。在特定情况下，如当用户登录密码出错N 次后，当用户频繁发贴时。 可对验证码作更复杂的变换，当用户输入验证码出错次数为N 时，增加其难度，如增加字符集、变化字体等。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多进程]]></title>
    <url>%2F%2Fblog%2F2017%2F05%2F13%2Fpython%E5%A4%9A%E8%BF%9B%E7%A8%8B.html</url>
    <content type="text"><![CDATA[由于Python下调用Linux的Shell命令都需要等待返回，所以常常我们设置的多线程都达不到效果，因此在调用shell命令不需要返回时，使用threading模块并不是最好的方法。Python提供了非常好用的多进程包multiprocessing，你只需要定义一个函数，Python会替你完成其他所有事情。借助这个包，可以轻松完成从单进程到并发执行的转换。 新建单一进程如果我们新建少量进程，可以如下：12345678910111213import multiprocessingimport timedef func(msg): for i in xrange(3): print msg time.sleep(1)if __name__ == "__main__": p = multiprocessing.Process(target=func, args=("hello", )) p.start() p.join() print "Sub-process done." 使用进程池是的，你没有看错，不是线程池。它可以让你跑满多核CPU，而且使用方法非常简单。注意要用apply_async，如果落下async，就变成阻塞版本了。 processes=4是最多并发进程数量。12345678910111213141516import multiprocessingimport timedef func(msg): for i in xrange(3): print msg time.sleep(1)if __name__ == "__main__": pool = multiprocessing.Pool(processes=4) for i in xrange(10): msg = "hello %d" %(i) pool.apply_async(func, (msg, )) pool.close() pool.join() print "Sub-process(es) done." 使用Pool，并需要关注结果更多的时候，我们不仅需要多进程执行，还需要关注每个进程的执行结果，如下：1234567891011121314151617181920import multiprocessingimport timedef func(msg): for i in xrange(3): print msg time.sleep(1) return "done " + msgif __name__ == "__main__": pool = multiprocessing.Pool(processes=4) result = [] for i in xrange(10): msg = "hello %d" %(i) result.append(pool.apply_async(func, (msg, ))) pool.close() pool.join() for res in result: print res.get() print "Sub-process(es) done."]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python重定向cookie处理]]></title>
    <url>%2F%2Fblog%2F2017%2F05%2F08%2Fpython%E9%87%8D%E5%AE%9A%E5%90%91cookie%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[首先说明一下，我使用的是 Python3 的 urllib，但 Python2.x 同理（使用 urllib2）。 想用脚本去登录一个网站。和很多网站一样，该网站使用 cookie 来保存会话信息。这个我以前是自己提取 response 中的 Set-Cookie 头来处理的。这次本想如法炮制，却发现没保存需要的 cookie，所以登录失败。很郁闷地想了半天，最后出去 wireshark 抓包，终于发现原来重要的 cookie 在登录后的应答中，但这个应答是个 302 重定向，所以 urllib 默认的 opener （urllib.request.urlopen）直接就跟从这个重定向了，没有对 cookie 进行任何处理。 我首先想到的是，不要跟从重定向。我看到有个 HTTPRedirectHandler，但文档里没写它怎么用。郁闷……自己找到 request.py 文件看源代码，折腾了好久无果，遂想到 Google （早该想到了。。。）于是找到了 StackOverflow 上。有两个解决办法：要么不跟从重定向，要么弄个 HTTPCookieProcessor 保存 cookie 信息。看我自己的需求，当然选后者了。而且，那个回答问题的人也没有给出如何不让它跟从重定向（所给代码只是在重定向前对 cookie 进行处理而已）。 于是，我再一次地打开了 http.cookiejar 的文档，尝试弄明白这东西到底怎么用。当初折腾 cookie 的时候，没弄明白这个，所以才自己处理的。 看 request.py 里的代码，这个 CookieJar 用起来相当不错：123456789101112131415161718HTTPCookieProcessorclass HTTPCookieProcessor(BaseHandler): def __init__(self, cookiejar=None): import http.cookiejar if cookiejar is None: cookiejar = http.cookiejar.CookieJar() self.cookiejar = cookiejar def http_request(self, request): self.cookiejar.add_cookie_header(request) return request def http_response(self, request, response): self.cookiejar.extract_cookies(response, request) return response https_request = http_request https_response = http_response 不过我需要将 cookie 信息保存到文件。从文档上看到有个 FileCookieJar。我尝试了下，出错了，没有 _really_load 方法，我晕。。。之后才注意到其源代码开头有个ASCII图：*1234567891011 CookieJar____ / \ \ FileCookieJar \ \ / | \ \ \MozillaCookieJar | LWPCookieJar \ \ | | \ | ---MSIEBase | \ | / | | \ | / MSIEDBCookieJar BSDDBCookieJar |/ MSIECookieJar *原来具体实现还在子类啊。好吧，我就用 MozillaCookieJar 好了。 用法很简单，初始化时把文件名传给它，载入用 load()，保存用 save()。不过要注意的是，文件不存在时不能载入，touch 个空文件出来也不行的。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件去重]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F29%2Fpython%E6%96%87%E4%BB%B6%E5%8E%BB%E9%87%8D.html</url>
    <content type="text"><![CDATA[高级写法1open('newdict.txt', 'w').write(''.join(set(open('dic.txt').readlines()))) 菜鸟写法12345678910111213#coding:utf-8ciku=open(r'all.csv','r') #打开需要去重文件xieci=open(r'quchong.csv','w') #打开处理后存放的文件cikus=ciku.readlines() list2 = &#123;&#125;.fromkeys(cikus).keys() #列表去重方法，将列表数据当作字典的键写入字典，依据字典键不可重复的特性去重i=1for line in list2: if line[0]!=',': # print line[0:-1].decode('utf-8').encode('gbk') #数据量太多，会出现编码报错。蛋疼 print u"写入第："+`i`+u" 个" i+=1 xieci.writelines(line)xieci.close()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取本机IP]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F25%2F%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAIP.html</url>
    <content type="text"><![CDATA[获取本机ip1234import sockets = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)s.connect(('google.com', 0))s.getsockname()[0] 获取本机名称：12import socketprint socket.gethostname()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 日期字符转时间戳]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F22%2Fpython-%E6%97%A5%E6%9C%9F%E5%AD%97%E7%AC%A6%E8%BD%AC%E6%97%B6%E9%97%B4%E6%88%B3.html</url>
    <content type="text"><![CDATA[12345&gt;&gt;&gt; import time&gt;&gt;&gt; import datetime&gt;&gt;&gt; s = "01/12/2011"&gt;&gt;&gt; time.mktime(datetime.datetime.strptime(s, "%d/%m/%Y").timetuple())1322697600.0]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 识别微信浏览器]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F21%2Fpython-%E8%AF%86%E5%88%AB%E5%BE%AE%E4%BF%A1%E6%B5%8F%E8%A7%88%E5%99%A8.html</url>
    <content type="text"><![CDATA[根据User Agent 来识别是否是微信浏览器 微信在 Android 下的 User Agent1mozilla/5.0 (linux; u; android 4.1.2; zh-cn; mi-one plus build/jzo54k) applewebkit/534.30 (khtml, like gecko) version/4.0 mobile safari/534.30 micromessenger/5.0.1.352 微信在 iPhone 下的 User Agent1mozilla/5.0 (iphone; cpu iphone os 5_1_1 like mac os x) applewebkit/534.46 (khtml, like gecko) mobile/9b206 micromessenger/5.0 只需判断是否包含关键字 micromessenger：12if 'micromessenger' in self.user_agent.lower(): return True]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVN 使用帮助]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F12%2FSVN-%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9.html</url>
    <content type="text"><![CDATA[同步至本地：新建文件夹，SNV checkout 输入用户名密码，确认。 上传文件：将要上传的文件放在一个文件夹里，选择要上传的文件所在的文件夹，右键单击，tortoiseSVN，Import，选择要放的位置，确认。 删除文件/文件夹：选中要删除的文件或文件夹，单击右键，tortoiseSVN，Delete，确认。 新建文件夹：在本地新建文件夹，单击右键，tortoiseSVN，Add，选择要添加的文件夹，确认。 ref： https://tortoisesvn.net/docs/nightly/TortoiseSVN_zh_CN/]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ find 函数用法]]></title>
    <url>%2F%2Fblog%2F2017%2F04%2F05%2FC-find-%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95.html</url>
    <content type="text"><![CDATA[头文件1#include &lt;algorithm&gt; 函数实现12345678910template&lt;class InputIterator, class T&gt;InputIterator find (InputIterator first, InputIterator last, const T&amp; val)&#123; while (first!=last) &#123; if (*first==val) return first; ++first; &#125; return last;&#125; 举例 vector 12345678910111213141516#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; m; m.push_back("hello"); m.push_back("hello2"); m.push_back("hello3"); if (find(m.begin(), m.end(), "hello") == m.end()) cout &lt;&lt; "no" &lt;&lt; endl; else cout &lt;&lt; "yes" &lt;&lt; endl;&#125; set 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; m; m.insert("hello"); m.insert("hello2"); m.insert("hello3"); if (find(m.begin(), m.end(), "hello") == m.end()) cout &lt;&lt; "no" &lt;&lt; endl; else cout &lt;&lt; "yes" &lt;&lt; endl;&#125; 注意： set自身有个find函数，举例如下： 1234567891011121314151617#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;int main()&#123; set&lt;string&gt; m; m.insert("hello"); m.insert("hello2"); m.insert("hello3"); if (find(m.begin(), m.end(), "hello") == m.end()) cout &lt;&lt; "no" &lt;&lt; endl; else cout &lt;&lt; "yes" &lt;&lt; endl;&#125; string自身有个find函数，举例如下： 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s = "helllo"; if (s.find("e") == string::npos) //yes cout &lt;&lt; "no" &lt;&lt; endl; else cout &lt;&lt; "yes" &lt;&lt; endl; if (s.find("z") == string::npos) //no cout &lt;&lt; "no" &lt;&lt; endl; else cout &lt;&lt; "yes" &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装Win7,Ubuntu双系统]]></title>
    <url>%2F%2Fblog%2F2017%2F03%2F20%2F%E5%AE%89%E8%A3%85Win7-Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F.html</url>
    <content type="text"><![CDATA[准备工作 官网下载Ubantu镜像，我下载的是Ubantu14.04.3 LTS版本 下载 Universal USB Installer (UUI)用于制作U盘启动盘 下载 Easy BCD 准备好U盘，容量不得小于4G，我看网上有说不小于2G的，实际操作时用的 4G U盘，制作好启动盘后只剩2M剩余空间，好险。U盘的实际容量是3.59G 在硬盘分出一定的空间，用于安装Ubantu，我腾出了300G的空间。硬盘分区软件可以使用 Minitool Partition WizardFree Edition。软件功能强大，容易上手，可以进行无损分区（不排除意外情况） 制作U盘启动盘 双击打开Universal-USB-Installer，选择“I Agree”，到下一个界面； 依次完成以下步骤，再点击Creat：step1中需要填入你要安装的ubuntu镜像文件的名称，选择 Ubantu；step2中需要找到你的ISO镜像文件的位置；step3选择要使用的U盘即可，其他不必勾选；Step4中将滑动条移到最右端。安装Ubuntu系统会出现的提示，让你选择优盘中保留给系统使用的永久存储空间。好像最大只能选择4G。如果空间足够，尽量多分一些，省掉以后不足的情况。如果是其他系统，不一定会有，可能系统直接自己分配了。 接下来是警告屏幕，如果前面的执行没有错误，点击“是”就OK了。 Be patient. 耐心等待，直到进度条满了为止，点击Close，启动盘就做好了。 安装Ubantu14.04系统 首先要确认的东西：U盘启动盘空闲的大于10G硬盘空间，多多益善，我新划出了一个300G的硬盘。计算机——右键属性——磁盘属性，可以看到你电脑上未分配的硬盘空间 在电脑上插入U盘启动盘，重启电脑，狂按 F2 或者 Del 键进入boot 界面（不同的电脑可能按键不一），进入boot 界面后，通过电脑键盘上的上下左右箭头按键调整选项，我们选择通过USB 启动那一项并按Enter 键进入。选择“Install Ubuntu“进入下一步 选择在“中文简体” 这个界面是现实你计算机的状态，下面有两个选项，如果你的网速较慢，建议不要选择，点击“继续” 这里要注意了，因为不同的选择会对计算机硬盘数据造成不同的后果，因为我要保留我的win7 系统，所以我选择“其他选项”，建议你们都选择这个，自己手动分区：然后选择“继续” 现在我们看到的是硬盘分区情况， 前边有“空闲”二字，我们要做的就是：在这个空闲的空间里给ubuntu划分分区，我习惯上是这么划分的 1234引导分区“/boot”300M足够了系统分区“/”装系统和软件93GB够用了交换分区“swap”类似windows的虚拟内存，一般不大于物理内存就行，我分的是15GB个人文件分区“/home”你想多大就多大，类似windows的“我的文档”。 点选“空闲“的分区，选择下边的”添加“，弹出窗口如下，上边填写分区空间大小，下边填写要挂载的分区，然后确定。”/“分区，”/home“分区都是这样子创建，而swap分区要在”用于“那里选择”交换分区“ 12345678910111213141516171819202122232425262728293031323334353637具体步骤：新分区的类型：选择“主分区”，新建分区容量：输入分配的大小，以MB 为单位新分区的位置：按默认选“起始”用于：后面选择新分区使用的文件系统，使用默认“Ext4 日志文件系统”挂载点：选择“/”。大小10~15G（可以根据个人而异）创建交换空间再选择空闲空间，点“添加”按钮。新分区的类型：选择“逻辑分区”新建分区容量：输入交换空间分配的大小，以MB 为单位新分区的位置：按默认选“起始”用于：后面选择“交换空间”交换空间不用选择挂载点，所以挂载点为灰色不可选笔者建议交换分区1024M创建“/home”分区继续选择空闲空间，点“添加”按钮。新分区的类型：逻辑分区新建分区容量：剩余的空间新分区的位置：起始用于：选择” Ext4 日志文件系统”挂载点：/home。点“确定”按钮。笔者在此分区12G（这个主要存放个人文档）创建“/boot”分区继续选择空闲空间，点“添加”按钮。新分区的类型：逻辑分区新建分区容量：200M 新分区的位置：起始用于：选择” Ext4 日志文件系统”挂载点：/boot。点“确定”按钮。因为我们安装是在Win７下安装，要的是双系统，所以要创建／boot 分区，否则这一项可以省略．注意：/分区就是linux系统的文件系统分区，类似windows 的系统盘，如c 盘；swap 为交换分区，一般为内存两倍;/boot 为引导分区200M足够；/home为个人文档分区重要提示；在采用u盘安装ubuntu分区时，所有磁盘一定要全部设置成逻辑分区，包括根目录/分区，否则将无法继续分区，这是本人亲身经历的教训，切记。其实正真的原因：在windows系统中再安装Ubuntu系统，主分区已经被windows系统占用（最多只有四个主分区），如在window系统中超过一个主分区，则在创建Ubuntu系统时，无法都设置为四个（/，swap，/home，／boot）主分区，因此都设置为主分区时无法继续分区，建议都设置为逻辑分区。 把分区设置好了，下边这步很关键！！！首先在上边看你创建的”/boot“分区的编号是什么，比如我的是sda6 （你的可能不是sda6,可能是sda5，sda7等等，取决于你的/boot分区编号），那么在下边的”安装启动引导区的设备“下拉选项框选择”sda6“,如果这步忽略了，你就用了ubuntu系统来引导windows了。 点“现在安装” 选择继续，进入下一步操作，并设置地区为：chongqing，按你需要设置，在下一步操作中选择语言 键盘布局“默认”，不用选了，点“继续” 这里设置系统用户，自己设置输入就可以了 系统开始安装，可以喝杯茶，等安装完毕就可以了 装完移除U盘重启，你会发现直接进入你的win7系统，因为我们把它的引导搞到/boot分区了。 我们要用EasyBCD 来给它创建启动时候的选择系统是windows还是ubuntu 。 用EasyBCD 创建启动系统 在网上下载一个EasyBCD软件，此软件用于在启动电脑的时候选择要进入的系统。 打开easyBCD，选择add new entry, 选择linux/BSD, name这一行随便填写，只是系统名词，写ubuntu吧，Device这一行选择刚刚我们创建的200MB的那个”/boot“分区,前边有linux标记的。 PS:EasyBCD很强大，不懂的别乱搞，搞坏MBR别怪我。 做完这些重启系统后，系统会将win7系统和ubuntu系统都列出来，你可以选择自己要进入的系统That’s all. 当你不要ubuntu的时候，直接在window里磁盘管理删了它所在的分区，然后在Easybcd里删了它的引导就行，不影响你的windows系统，这就是为啥我不用ubuntu来引导windows的原因。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>tools</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git: 代码冲突常见解决方法]]></title>
    <url>%2F%2Fblog%2F2017%2F03%2F18%2FGit-%E4%BB%A3%E7%A0%81%E5%86%B2%E7%AA%81%E5%B8%B8%E8%A7%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[如果系统中有一些配置文件在服务器上做了配置修改,然后后续开发又新添加一些配置项的时候, 在发布这个配置文件的时候,会发生代码冲突:123error: Your local changes to the following files would be overwritten by merge: protected/config/main.phpPlease, commit your changes or stash them before you can merge. 如果希望保留生产服务器上所做的改动,仅仅并入新配置项, 处理方法如下:123$ git stash$ git pull$ git stash pop 然后可以使用git diff -w +文件名 来确认代码自动合并的情况. 反过来,如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:12$ git reset --hard$ git pull 其中git reset是针对版本,如果想针对文件回退本地修改,使用’1$ git checkout HEAD file/to/restore 在 checkout 或者 rebase 时, 如果提示:12Please move or remove them before you can switch branches.Aborting 执行:1$ git clean -d -fx 有时 push 代码的时候, 出现提示:1234$ git pushTo ../remote/ ! [rejected] master -&gt; master (non-fast-forward)error: failed to push some refs to '../remote/' 问题 (Non-fast-forward) 的出现原因在于: git remote 仓库中已经有一部分代码, 所以它不允许你直接把你的代码覆盖上去. 于是你有 2 个选择方式: 强推, 即利用强覆盖方式用你本地的代码替代 git 仓库内的内容 1$ git push -f 先把 git 的东西 fetch 到你本地然后 merge 后再 push 12$ git fetch$ git merge]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++读取txt文件]]></title>
    <url>%2F%2Fblog%2F2017%2F03%2F10%2FC-%E8%AF%BB%E5%8F%96txt%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[逐行读入12345678910111213void readTxt(string file)&#123; ifstream infile; infile.open(file.data()); //将文件流对象与文件连接起来 assert(infile.is_open()); //若失败,则输出错误消息,并终止程序运行 string s; while(getline(infile,s)) &#123; cout&lt;&lt;s&lt;&lt;endl; &#125; infile.close(); //关闭文件输入流 &#125; 逐个字符读入（忽略空格与回车1234567891011121314void readTxt(string file) ifstream infile; infile.open(file.data()); //将文件流对象与文件连接起来 assert(infile.is_open()); //若失败,则输出错误消息,并终止程序运行 char c; while (!infile.eof()) &#123; infile &gt;&gt; c; cout&lt;&lt;c&lt;&lt;endl; &#125; infile.close(); //关闭文件输入流 &#125; 逐个字符读入（包括空格与回车）12345678910111213141516void readTxt(string file)&#123; ifstream infile; infile.open(file.data()); //将文件流对象与文件连接起来 assert(infile.is_open()); //若失败,则输出错误消息,并终止程序运行 char c; infile &gt;&gt; noskipws; while (!infile.eof()) &#123; infile&gt;&gt;c; cout&lt;&lt;c&lt;&lt;endl; &#125; infile.close(); //关闭文件输入流 &#125; 所需的头文件1234#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cassert&gt;#include &lt;string&gt;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在C++中调用python]]></title>
    <url>%2F%2Fblog%2F2017%2F03%2F03%2F%E5%9C%A8C-%E4%B8%AD%E8%B0%83%E7%94%A8python.html</url>
    <content type="text"><![CDATA[c++中调用python 的属性配置将python安装目录下的include和libs文件夹分别包含在VC++目录下，如下图：c++中调用python 的实例code 1:1234567891011#include &lt;iostream&gt; #include &lt;Python.h&gt; using namespace std;int main(int argc, char *argv[])&#123; Py_Initialize(); PyRun_SimpleString("print 'Hello Python!'\n"); Py_Finalize(); return 0;&#125; code2:1234567891011121314151617181920212223242526//.cpp调用pyhton .py文件#include &lt;iostream&gt;#include &lt;Python.h&gt;using namespace std;int main()&#123; Py_Initialize(); PyObject * pModule = NULL; PyObject * pFunc = NULL; pModule = PyImport_ImportModule("py_test"); if (!pModule)&#123; cout &lt;&lt; "get module failed!" &lt;&lt; endl; exit(0); &#125; pFunc = PyObject_GetAttrString(pModule, "Hello"); PyEval_CallObject(pFunc, NULL); Py_Finalize(); return 0;&#125; 12345#py_test.pydef Hello(): print "Hello, Jason" 下面是调用python脚本的一般步骤： windows VS环境，首先在C++的工程文件总增加python安装目录下的include(附加包含目录)和libs目录(附加库目录)。 在需要用到python的C++文件中，添加#include “Python.h” 引用python的代码部分，都需要以Py_Initialize()开始，用Py_Finalize()结束 python相关的对象多半声明为PyObject指针，如PyObject pstr, pmod, pdict, pfunc, *pargs等 最简单的调用一段python代码的方法：PyRun_SimpleString(“…”); 导入一个模块：pModule= PyImport_ImportModule(“script”) //script，脚本的名字调用其中的一个函数Hello( ) pfunc = PyObject_GetAttrString(pModule, “Hello”);用指定的参数运行这个函数：PyEval_CallObject(pfunc, pargs); 步骤6的另一种做法：导入一个模块：pname = PyString_FromString(“script”); pModule = PyImport_Import(pname); 调用其中的函数pyPrint(name1, name2)pdict = PyModule_GetDict(pModule); pfunc = PyDict_GetItemString(pdict, “pyPrint”); pargs = Py_BuildValue(“s, s”, “Hello World”, “again”); 运行这个函数：PyEval_CallObject(pfunc, pargs);注意，当py函数没有参数时，pargs = NULL 释放PyObject 指针：Py_DECREF(pobj)下面code3实例为python脚本带参数：12345678910111213141516171819//python函数带参数#include &lt;python.h&gt;int main()&#123; Py_Initialize(); PyObject * pModule = NULL; PyObject * pFunc = NULL; PyObject * pArg = NULL; pModule = PyImport_ImportModule("py_test2_para"); pFunc = PyObject_GetAttrString(pModule, "add"); pArg = Py_BuildValue("(i,i)", 10, 15); //构造一个元组 PyEval_CallObject(pFunc, pArg); Py_Finalize(); return 0;&#125; 1234#py_test_para.py，带参数def add(a, b): print "a+b=", a+b opencv中调用python除了上面调用python脚本的方法，还可以使用c++代码中直接嵌入方式，先附一段嵌入的python代码： 123456789101112/* embedding Python code */char *pycode ="from scipy import signal\n""def bwlp(order, f, samplingRate):\n"" b, a = signal.butter(order, f/samplingRate, 'low', analog=False)\n"" return b, a\n""a, b = bwlp(1, f, samplingRate)\n""a0 = a[0]\n""a1 = a[1]\n""b0 = b[0]\n""b1 = b[1]\n"; 下面使用上面的python代码：123456789101112131415161718192021222324252627282930313233double low_a[2], low_b[2], high_a[2], high_b[2];// call python butter funcPyObject *main_module, *main_dict;PyObject *b0_obj, *b1_obj, *a0_obj, *a1_obj, *f_obj, *samplerate_obj;Py_Initialize(); // 检查初始化是否成功 if ( !Py_IsInitialized() ) &#123; return -1; &#125; /* Setup the __main__ module to use */main_module = PyImport_ImportModule("__main__");main_dict = PyModule_GetDict(main_module);/* C var to Python var */samplerate_obj = PyInt_FromLong(long(samplingRate));f_obj = PyFloat_FromDouble(fl);/* inject var into __main__ */PyDict_SetItemString(main_dict, "f", f_obj);PyDict_SetItemString(main_dict, "samplingRate", samplerate_obj);PyRun_SimpleString(pycode);/* Extract the resultant var, double a, b */b0_obj = PyMapping_GetItemString(main_dict, "b0");a0_obj = PyMapping_GetItemString(main_dict, "a0");b1_obj = PyMapping_GetItemString(main_dict, "b1");a1_obj = PyMapping_GetItemString(main_dict, "a1");low_b[0] = PyFloat_AsDouble(b0_obj);low_b[1] = PyFloat_AsDouble(b1_obj);low_a[0] = PyFloat_AsDouble(a0_obj);low_a[1] = PyFloat_AsDouble(a1_obj);Py_Finalize();]]></content>
      <categories>
        <category>C++</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STL使用方法]]></title>
    <url>%2F%2Fblog%2F2017%2F03%2F02%2FSTL%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[什么是STL？STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但这种分离确实使得STL变得非常通用。例如，由于STL的sort()函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组；STL另一个重要特性是它不是面向对象的。为了具有足够通用性，STL主要依赖于模板而不是封装，继承和虚函数（多态性）——OOP的三个要素。你在STL中找不到任何明显的类继承关系。这好像是一种倒退，但这正好是使得STL的组件具有广泛通用性的底层特征。另外，由于STL是基于模板，内联函数的使用使得生成的代码短小高效；从逻辑层次来看，在STL中体现了泛型化程序设计的思想，引入了诸多新的名词，比如像需求（requirements），概念（concept），模型（model），容器（container），算法（algorithmn），迭代子（iterator）等。与OOP（object-oriented programming）中的多态（polymorphism）一样，泛型也是一种软件的复用技术；从实现层次看，整个STL是以一种类型参数化的方式实现的，这种方式基于一个在早先C++标准中没有出现的语言特性–模板（template）。 STL内容介绍STL中六大组件：1234561）容器（Container），是一种数据结构，如list，vector，和deques ，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；2）迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；3）算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；4）仿函数（Function object）5）迭代适配器（Adaptor）6）空间配制器（allocator） 下面将依次介绍STL的这三个主要组件。 容器STL中的容器有队列容器和关联容器，容器适配器（congtainer adapters：stack,queue，priority queue），位集（bit_set），串包(string_package)等等。（1）序列式容器（Sequence containers），每个元素都有固定位置－－取决于插入时机和地点，和元素值无关，vector、deque、list；Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；（2）关联式容器（Associated containers），元素位置取决于特定的排序准则，和插入顺序无关，set、multiset、map、multimap；Sets/Multisets：内部的元素依据其值自动排序，Set内的相同数值的元素只能出现一次，Multisets内可包含多个数值相同的元素，内部由二叉树实现，便于查找；Maps/Multimaps：Map的元素是成对的键值/实值，内部的元素依据其值自动排序，Map内的相同数值的元素只能出现一次，Multimaps内可包含多个数值相同的元素，内部由二叉树实现，便于查找；容器类自动申请和释放内存，无需new和delete操作。vector基于模板实现，需包含头文件vector。 12345678910111213141516171819202122232425262728293031//1.定义和初始化 vector&lt;int&gt; vec1; //默认初始化，vec1为空 vector&lt;int&gt; vec2(vec1); //使用vec1初始化vec2 vector&lt;int&gt; vec3(vec1.begin(),vec1.end());//使用vec1初始化vec2 vector&lt;int&gt; vec4(10); //10个值为的元素 vector&lt;int&gt; vec5(10,4); //10个值为的元素//2.常用操作方法 vec1.push_back(100); //添加元素 int size = vec1.size(); //元素个数 bool isEmpty = vec1.empty(); //判断是否为空 cout&lt;&lt;vec1[0]&lt;&lt;endl; //取得第一个元素 vec1.insert(vec1.end(),5,3); //从vec1.back位置插入个值为的元素 vec1.pop_back(); //删除末尾元素 vec1.erase(vec1.begin(),vec1.end());//删除之间的元素，其他元素前移 cout&lt;&lt;(vec1==vec2)?true:false; //判断是否相等==、！=、&gt;=、&lt;=... vector&lt;int&gt;::iterator iter = vec1.begin(); //获取迭代器首地址 vec1.clear(); //清空元素//3.遍历 //下标法 int length = vec1.size(); for(int i=0;i&lt;length;i++) &#123; cout&lt;&lt;vec1[i]; &#125; cout&lt;&lt;endl&lt;&lt;endl; //迭代器法 vector&lt;int&gt;::const_iterator iterator = vec1.begin(); for(;iterator != vec1.end();iterator++) &#123; cout&lt;&lt;*iterator; &#125; STL迭代器Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。 迭代器的作用：能够让迭代器与算法不干扰的相互发展，最后又能无间隙的粘合起来，重载了，＋＋，＝＝，！＝，＝运算符。用以操作复杂的数据结构，容器提供迭代器，算法使用迭代器；常见的一些迭代器类型：iterator、const_iterator、reverse_iterator和const_reverse_iterator,实例如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; v.push_back(3); //数组尾部插入3 v.push_back(2); v.push_back(1); v.push_back(0); cout &lt;&lt; " 下标 " &lt;&lt; v[3] &lt;&lt; endl; cout &lt;&lt; " 迭代器 " &lt;&lt; endl; for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; " "; &#125; cout &lt;&lt; endl; //在第一个元素之前插入111 insert begin+n是在第n个元素之前插入 v.insert(v.begin(),111); //在最后一个元素之后插入222 insert end + n 是在n个元素之后插入 v.insert(v.end(),222); for(vector&lt;int&gt;::iterator i = v.begin();i!= v.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; " "; &#125; cout &lt;&lt; endl; vector&lt;int&gt; arr(10); for(int i = 0; i &lt; 10; i++) &#123; arr[i] = i; &#125; for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; " "; &#125; cout &lt;&lt; endl; //删除 同insert arr.erase(arr.begin()); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; " " ; &#125; cout &lt;&lt; endl ; arr.erase(arr.begin(),arr.begin()+5); for(vector&lt;int&gt;::iterator i = arr.begin();i!= arr.end();++i) &#123; cout &lt;&lt; *i &lt;&lt; " " ; &#125; cout &lt;&lt; endl ; return 0 ; &#125; 实例2：1234567891011121314151617181920212223242526数组转置 (&lt;algorithm&gt; reverse) reverse(v.begin(),v.end())&lt;span style="font-size:14px;"&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;int&gt; v; for(int i = 0; i &lt; 10; ++i) &#123; v.push_back(i); &#125; for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; reverse(v.begin(),v.end()); for(vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) &#123; cout &lt;&lt; *it &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125;&lt;/span&gt; 算法函数库对数据类型的选择对其可重用性起着至关重要的作用。举例来说，一个求方根的函数，在使用浮点数作为其参数类型的情况下的可重用性肯定比使用整型作为它的参数类性要高。而C++通过模板的机制允许推迟对某些类型的选择，直到真正想使用模板或者说对模板进行特化的时候，STL就利用了这一点提供了相当多的有用算法。它是在一个有效的框架中完成这些算法的——你可以将所有的类型划分为少数的几类，然后就可以在模版的参数中使用一种类型替换掉同一种类中的其他类型。STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数，stable_sort以你所指定的规则对序列进行稳定性排序等等。只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法模板，就可以完成所需要的功能并大大地提升效率。算法部分主要由头文件，和组成。 是所有STL头文件中最大的一个（尽管它很好理解），它是由一大堆模版函数组成的，可以认为每个函数在很大程度上都是独立的，其中常用到的功能范围涉及到比较、交换、查找、遍历操作、复制、修改、移除、反转、排序、合并等等。 体积很小，只包括几个在序列上面进行简单数学运算的模板函数，包括加法和乘法在序列上的一些操作。 中则定义了一些模板类，用以声明函数对象。STL中算法大致分为四类：1）非可变序列算法：指不直接修改其所操作的容器内容的算法。2）可变序列算法：指可以修改它们所操作的容器内容的算法。3）排序算法：对序列进行排序和合并的算法、搜索算法以及有序序列上的集合操作。4）数值算法：对容器内容进行数值计算。以下对所有算法进行细致分类并标明功能： 查找算法(13个)：判断容器中是否包含某个值adjacent_find: 在iterator对标识元素范围内，查找一对相邻重复元素，找到则返回指向这对元素的第一个元素的ForwardIterator。否则返回last。重载版本使用输入的二元操作符代替相等的判断。binary_search: 在有序序列中查找value，找到返回true。重载的版本实用指定的比较函数对象或函数指针来判断相等。count: 利用等于操作符，把标志范围内的元素与输入值比较，返回相等元素个数。count_if: 利用输入的操作符，对标志范围内的元素进行操作，返回结果为true的个数。equal_range: 功能类似equal，返回一对iterator，第一个表示lower_bound，第二个表示upper_bound。find: 利用底层元素的等于操作符，对指定范围内的元素与输入值进行比较。当匹配时，结束搜索，返回该元素的一个InputIterator。find_end: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”的最后一次出现。找到则返回最后一对的第一个ForwardIterator，否则返回输入的”另外一对”的第一个ForwardIterator。重载版本使用用户输入的操作符代替等于操作。find_first_of: 在指定范围内查找”由输入的另外一对iterator标志的第二个序列”中任意一个元素的第一次出现。重载版本中使用了用户自定义操作符。find_if: 使用输入的函数代替等于操作符执行find。lower_bound: 返回一个ForwardIterator，指向在有序序列范围内的可以插入指定值而不破坏容器顺序的第一个位置。重载函数使用自定义比较操作。upper_bound: 返回一个ForwardIterator，指向在有序序列范围内插入value而不破坏容器顺序的最后一个位置，该位置标志一个大于value的值。重载函数使用自定义比较操作。search: 给出两个范围，返回一个ForwardIterator，查找成功指向第一个范围内第一次出现子序列(第二个范围)的位置，查找失败指向last1。重载版本使用自定义的比较操作。search_n: 在指定范围内查找val出现n次的子序列。重载版本使用自定义的比较操作。 排序和通用算法(14个)：提供元素排序策略inplace_merge: 合并两个有序序列，结果序列覆盖两端范围。重载版本使用输入的操作进行排序。merge: 合并两个有序序列，存放到另一个序列。重载版本使用自定义的比较。nth_element: 将范围内的序列重新排序，使所有小于第n个元素的元素都出现在它前面，而大于它的都出现在后面。重载版本使用自定义的比较操作。partial_sort: 对序列做部分排序，被排序元素个数正好可以被放到范围内。重载版本使用自定义的比较操作。partial_sort_copy: 与partial_sort类似，不过将经过排序的序列复制到另一个容器。partition: 对指定范围内元素重新排序，使用输入的函数，把结果为true的元素放在结果为false的元素之前。random_shuffle: 对指定范围内的元素随机调整次序。重载版本输入一个随机数产生操作。reverse: 将指定范围内元素重新反序排序。reverse_copy: 与reverse类似，不过将结果写入另一个容器。rotate: 将指定范围内元素移到容器末尾，由middle指向的元素成为容器第一个元素。rotate_copy: 与rotate类似，不过将结果写入另一个容器。sort: 以升序重新排列指定范围内的元素。重载版本使用自定义的比较操作。stable_sort: 与sort类似，不过保留相等元素之间的顺序关系。stable_partition: 与partition类似，不过不保证保留容器中的相对顺序。 删除和替换算法(15个)copy: 复制序列copy_backward: 与copy相同，不过元素是以相反顺序被拷贝。iter_swap: 交换两个ForwardIterator的值。remove: 删除指定范围内所有等于指定元素的元素。注意，该函数不是真正删除函数。内置函数不适合使用remove和remove_if函数。remove_copy: 将所有不匹配元素复制到一个制定容器，返回OutputIterator指向被拷贝的末元素的下一个位置。remove_if: 删除指定范围内输入操作结果为true的所有元素。remove_copy_if: 将所有不匹配元素拷贝到一个指定容器。replace: 将指定范围内所有等于vold的元素都用vnew代替。replace_copy: 与replace类似，不过将结果写入另一个容器。replace_if: 将指定范围内所有操作结果为true的元素用新值代替。replace_copy_if: 与replace_if，不过将结果写入另一个容器。swap: 交换存储在两个对象中的值。swap_range: 将指定范围内的元素与另一个序列元素值进行交换。unique: 清除序列中重复元素，和remove类似，它也不能真正删除元素。重载版本使用自定义比较操作。unique_copy: 与unique类似，不过把结果输出到另一个容器。 排列组合算法(2个)：提供计算给定集合按一定顺序的所有可能排列组合next_permutation: 取出当前范围内的排列，并重新排序为下一个排列。重载版本使用自定义的比较操作。prev_permutation: 取出指定范围内的序列并将它重新排序为上一个序列。如果不存在上一个序列则返回false。重载版本使用自定义的比较操作。 算术算法(4个)accumulate: iterator对标识的序列段元素之和，加到一个由val指定的初始值上。重载版本不再做加法，而是传进来的二元操作符被应用到元素上。partial_sum: 创建一个新序列，其中每个元素值代表指定范围内该位置前所有元素之和。重载版本使用自定义操作代替加法。inner_product: 对两个序列做内积(对应元素相乘，再求和)并将内积加到一个输入的初始值上。重载版本使用用户定义的操作。adjacent_difference: 创建一个新序列，新序列中每个新值代表当前元素与上一个元素的差。重载版本用指定二元操作计算相邻元素的差。 生成和异变算法(6个)fill: 将输入值赋给标志范围内的所有元素。fill_n: 将输入值赋给first到first+n范围内的所有元素。for_each: 用指定函数依次对指定范围内所有元素进行迭代访问，返回所指定的函数类型。该函数不得修改序列中的元素。generate: 连续调用输入的函数来填充指定的范围。generate_n: 与generate函数类似，填充从指定iterator开始的n个元素。transform: 将输入的操作作用与指定范围内的每个元素，并产生一个新的序列。重载版本将操作作用在一对元素上，另外一个元素来自输入的另外一个序列。结果输出到指定容器。 关系算法(8个)equal: 如果两个序列在标志范围内元素都相等，返回true。重载版本使用输入的操作符代替默认的等于操作符。includes: 判断第一个指定范围内的所有元素是否都被第二个范围包含，使用底层元素的&lt;操作符，成功返回true。重载版本使用用户输入的函数。lexicographical_compare: 比较两个序列。重载版本使用用户自定义比较操作。max: 返回两个元素中较大一个。重载版本使用自定义比较操作。max_element: 返回一个ForwardIterator，指出序列中最大的元素。重载版本使用自定义比较操作。min: 返回两个元素中较小一个。重载版本使用自定义比较操作。min_element: 返回一个ForwardIterator，指出序列中最小的元素。重载版本使用自定义比较操作。mismatch: 并行比较两个序列，指出第一个不匹配的位置，返回一对iterator，标志第一个不匹配元素位置。如果都匹配，返回每个容器的last。重载版本使用自定义的比较操作。 集合算法(4个)set_union: 构造一个有序序列，包含两个序列中所有的不重复元素。重载版本使用自定义的比较操作。set_intersection: 构造一个有序序列，其中元素在两个序列中都存在。重载版本使用自定义的比较操作。set_difference: 构造一个有序序列，该序列仅保留第一个序列中存在的而第二个中不存在的元素。重载版本使用自定义的比较操作。set_symmetric_difference: 构造一个有序序列，该序列取两个序列的对称差集(并集-交集)。 堆算法(4个)make_heap: 把指定范围内的元素生成一个堆。重载版本使用自定义比较操作。pop_heap: 并不真正把最大元素从堆中弹出，而是重新排序堆。它把first和last-1交换，然后重新生成一个堆。可使用容器的back来访问被”弹出”的元素或者使用pop_back进行真正的删除。重载版本使用自定义的比较操作。push_heap: 假设first到last-1是一个有效堆，要被加入到堆的元素存放在位置last-1，重新生成堆。在指向该函数前，必须先把元素插入容器后。重载版本使用指定的比较操作。sort_heap: 对指定范围内的序列重新排序，它假设该序列是个有序堆。重载版本使用自定义比较操作。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 打开程序和文件的方法]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F25%2Fpython-%E6%89%93%E5%BC%80%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[打开程序12345import subprocessp=subprocess.Popen("calc.exe",0,None,None,None,None)p.wait() p=subprocess.Popen("D:\Program Files\Tencent\QQ\Bin\QQ.exe",0,None,None,None,None)p.wait() 打开文件123import osos.system("notepad") os.system("c:\\test.txt")]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime python 配置]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F17%2Fsublime-python-%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[Package Control 安装方法 通过快捷键 ctrl+` 或者 View &gt; Show Console 打开控制台，然后粘贴相应的 Python 安装代码； Sublime Text 3 安装代码并回车： 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 重启Sublime Text 3； 如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。 用Package Control安装插件的方法：按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。Pylinter.sublime-settings 配置了pylinter 插件。我使用下面的配置让 Pyhton 在保存时自动规范，并对违反规范显示图标。 12345678910111213&#123; // Configure pylint's behavior "pylint_rc": "/Users/daniel/dev/pylintrc", // Show different icons for errors, warnings, etc. "use_icons": true, // Automatically run Pylinter when saving a Python document "run_on_save": true, // Don't hide pylint messages when moving the cursor "message_stay": true&#125; SublimeCodeIntel 插件 智能提示插件，这个插件的智能提示功能非常强大，可以自定义提示的内容库，我的Python智能提示设置1234567891011"Python": &#123; "python":"D:/Python27/python.exe", "pythonExtraPaths": [ "D:/Python27", "D:/Python27/DLLs", "D:/Python27/Lib", "D:/Python27/Lib/lib-tk", "D:/Python27/Lib/site-packages" ] &#125; Python PEP8 Autoformat 插件 这是用来按PEP8自动格式化代码的。可以在包管理器中安装。快捷键 CTRL+SHIFT+R 自动格式化python代码 常用配置1234567891011121314151617&#123; "auto_complete": false, "caret_style": "solid", "ensure_newline_at_eof_on_save": true, "find_selected_text": true, "font_size": 11.0, "highlight_modified_tabs": true, "line_padding_bottom": 0, "line_padding_top": 0, "scroll_past_end": false, "show_minimap": false, "tab_size": 4, "translate_tabs_to_spaces": true, "trim_trailing_white_space_on_save": true, "wide_caret": true, "word_wrap": true,&#125; F12 或 CTRL+B 运行 py文件如果是F12最好在py文件后加raw_input()否则CMD会一闪而过.]]></content>
      <categories>
        <category>tools</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS常用命令]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F16%2FCentOS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[一：使用CentOS常用命令查看cpu12345more /proc/cpuinfo | grep “model name”grep “model name” /proc/cpuinfo[root@localhost /]# grep “CPU” /proc/cpuinfomodel name : Intel(R) Pentium(R) Dual CPU E2180 @ 2.00GHzmodel name : Intel(R) Pentium(R) Dual CPU E2180 @ 2.00GHz 如果觉得需要看的更加舒服1grep “model name” /proc/cpuinfo | cut -f2 -d: 二：使用CentOS常用命令查看内存12345grep MemTotal /proc/meminfogrep MemTotal /proc/meminfo | cut -f2 -d:free -m |grep “Mem” | awk ‘&#123;print $2&#125;’ 三：使用CentOS常用命令查看cpu是32位还是64位查看CPU位数(32 or 64)1getconf LONG_BIT 四：使用CentOS常用命令查看当前linux的版本12more /etc/redhat-releasecat /etc/redhat-release 五：使用CentOS常用命令查看内核版本12uname -runame -a 六：使用CentOS常用命令查看当前时间1date 七：使用CentOS常用命令查看硬盘和分区12df -hfdisk -l 也可以查看分区1du -sh 可以看到全部占用的空间1du /etc -sh 可以看到这个目录的大小 八：使用CentOS常用命令查看安装的软件包查看系统安装的时候装的软件包12cat -n /root/install.logmore /root/install.log | wc -l 查看现在已经安装了那些软件包123rpm -qarpm -qa | wc -lyum list installed | wc -l 不过很奇怪，我通过rpm，和yum这两种方式查询的安装软件包，数量并不一样。没有找到原因。 九：使用CentOS常用命令查看键盘布局12cat /etc/sysconfig/keyboardcat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d= 十：使用CentOS常用命令查看selinux情况123sestatussestatus | cut -f2 -d:cat /etc/sysconfig/selinux 十一：使用CentOS常用命令查看ip，mac地址在ifcfg-eth0 文件里你可以看到mac，网关等信息。12345678910ifconfigcat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDRcat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2-d=ifconfigeth0 |grep “inet addr:” |awk ‘&#123;print $2&#125;’|cut -c 6-ifconfig | grep ‘inet addr:’| grep -v ‘127.0.0.1’ | cut -d: -f2 | awk ‘&#123; print $1&#125;’ 查看网关1cat /etc/sysconfig/network 查看dns1cat /etc/resolv.conf 十二：使用CentOS常用命令查看默认语言12echo $LANG $LANGUAGEcat /etc/sysconfig/i18n 十三：使用CentOS常用命令查看所属时区和是否使用UTC时间1cat /etc/sysconfig/clock 十四：使用CentOS常用命令查看主机名12hostnamecat /etc/sysconfig/network 修改主机名就是修改这个文件，同时最好也把host文件也修改。 十五：使用CentOS常用命令查看 系统资源使用情况 ( 开机运行时间 )12uptime09:44:45 up 67 days, 23:32, … 看来刚才确实是网段的问题，我的机器还是67天前开机的。系统资源使用情况 vmstat 1 -S m procs ———–memory———- —swap– —–io—- –system– —–cpu—— r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 233 199 778 0 0 4 25 1 1 3 0 96 0 0 0 0 0 233 199 778 0 0 0 0 1029 856 13 1 86 0 0 十六：实用命令12345wget 网址 下载资源tar zxvf 压缩包名称 解压hostname or cat /etc/sysconfig/network 查看主机名pkill mysqld 如何杀死mysql进程find / -type f -size +100000k -ls 查询大小超过100M的文件 十七：CentOS文件常用命令创建/改变文件系统的CentOS常用命令 NO1. 创建文件系统类型123[root@rehat root]# umount /dev/sdb1[root@rehat root]# mkfs -t ext3 /dev/db1[root@rehat root]# mount /dev/sdb1 /practice 改变文件或文件夹权限的CentOS常用命令 chmodNO1. 将自己的笔记设为只有自己才能看1234567[root@rehat root]# chmod go-rwx test.txt或者[root@rehat root]# chmod 700 test.txtNO2. 同时修改多个文件的权限[root@rehat root]# chmod 700 test1.txt test2.txtNO3. 修改一个目录的权限，包括其子目录及文件[root@rehat root]# chmod 700 -R test 改变文件或文件夹拥有者的CentOS常用命令12345chown 该命令只有 root 才能使用NO1. 更改某个文件的拥有者[root@rehat root]# chown jim:usergroup test.txtNO2. 更改某个目录的拥有者,并包含子目录[root@rehat root]# chown jim:usergroup -R test 查看文本文件内容的CentOS常用命令 cat123456789101112NO1. 查看文件内容，并在每行前面加上行号[root@rehat root]# cat -n test.txtNO2. 查看文件内容，在不是空行的前面加上行号[root@rehat root]# cat -b test.txtNO3. 合并两个文件的内容[root@rehat root]# cat test1.txt test2.txt &gt; test_new.txtNO4. 全并两具文件的内容，并追回到一个文件[root@rehat root]# cat test1.txt test2.txt &gt;&gt; test_total.txtNO5. 清空某个文件的内容[root@rehat root]# cat /dev/null &gt; test.txtNO6. 创建一个新的文件[root@rehat root]# cat &gt; new.txt 按 CTRL + C 结束录入 编辑文件文件的CentOS常用命令 vi1234567891011NO1. 新建档案文件[root@rehat root]# vi newfile.txtNO2. 修改档案文件[root@rehat root]# vi test.txt test.txt 已存在NO3. vi 的两种工作模式：命令模式，编辑模式NO4. 进入 vi 后为命令模式，按 Insrt 键进入编辑模式按 ESC 进入命令模式，在命令模式不能编辑，只能输入命令NO5. 命令模式常用命令:w 保存当前文档:q 直接退出 vi:wq 先保存后退出 。 十八：批量替换文件今天使用svn进行系统迁移，结果发现最初的路径写错了，导致无法访问源服务器，查看 .svn/entries 大致了解了一下里面的内容。重新迁移时间太久了，还是直接把文件替换掉吧1234for f in $(find ./ -type f -name ‘entries’)dosed -i “s/202\.68\.134\.18/202\.68\.134\.34/g” $fdone sed 简单说明:1sed “s/sourcestring/newstring/g” $f 把 $f 文件中的 sourcestring 换成 newstring，输出到终端。s 表示搜索替换，/g表示全局。1sed -i $f 表示直接在 $f 中修改。1sed -iback $f 表示修改后的文件另存为 $fback12345sed 中所有正则表达式都必须使用严格的转义符 \ 来限定sed 的正则比较严格： ” \ / ! 都需要分别用 \” \/ \\ \! 转义。\n 表示换行 十九. shell 变量 字符串操作mono 跑在linux下时，apache+mod_mono有时候需要加载的 Assembly 必须配置在 GAC 中，下面是一个脚本完成此功能123456789cd binfor f in $(find ./ -name “*.dll”)dogacutil -i $fdone 如果要从 GAC 中批量卸载这些 Assembly, 可以如下1234567for f in $(ls *.dll)dogacutil -u $&#123;f%%.dll&#125;done 其中就用到了字符串变量的替换， ${f%%.dll} ${f%%.dll} 的意义为 删除 $f 变量 .dll 及之后的所有内容 相关的变量操作还有: ${f##.} 等，后面再补充 二十、 查看当前连接netstat -an 二十一、有关重启shutdown -r now 重新启动系统，使设置生效shutdown -h now 关机reboot 重启poweroff 关机 二十二、开机自启动设置编辑rc.local文件12345678910111213141516171819202122#vim /etc/rc.d/rc.local# du -sh # 查看指定目录的大小# uptime # 查看系统运行时间、用户数、负载# cat /proc/loadavg # 查看系统负载# iptables -L # 查看防火墙设置# route -n # 查看路由表# netstat -lntp # 查看所有监听端口# netstat -antp # 查看所有已经建立的连接# netstat -s # 查看网络统计信息# w # 查看活动用户# id # 查看指定用户信息# last # 查看用户登录日志# cut -d: -f1 /etc/passwd # 查看系统所有用户# cut -d: -f1 /etc/group # 查看系统所有组# crontab -l # 查看当前用户的计划任务# chkconfig –list # 列出所有系统服务# chkconfig –list | grep on # 列出所有启动的系统服务]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sh语法基础]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F06%2Fsh%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[玩linux都知道sh脚本的方便，但如何编写sh脚本却是像我这样的新手和菜鸟的难题。能不能编写得出来是一回事，了不了解又是另一回事。抱着好好学习，天天向上的精神，大家有空就看看吧，没有坏处的。下面来抄来一大段sh脚本的语法说明。慢慢看： 一、开头程序必须以下面的行开始（必须方在文件的第一行）：1#!/bin/sh 符号#!用来告诉系统它后面的参数是用来执行该文件的程序。在这个例子中我们使用/bin/sh来执行程序。当编写脚本完成时，如果要执行该脚本，还必须使其可执行。要使编写脚本可执行：编译 chmod +x filename 这样才能用./filename 来运行 二、注释在进行shell编程时，以#开头的句子表示注释，直到这一行的结束。 三、变量在shell编程中，所有的变量都由字符串组成，并且不需要对变量进行声明。要赋值给一个变量，可以这样写：1#!/bin/sh 对变量赋值：1a=”hello world” 现在打印变量a的内容：12echo “A is:”echo $a 有时候变量名很容易与其他文字混淆，比如：12num=2echo “this is the $numnd” 这并不会打印出”this is the 2nd”，而仅仅打印”this is the “，因为shell会去搜索变量numnd的值，但是这个变量时没有值的。可以使用花括号来告诉shell我们要打印的是num变量：12num=2echo “this is the $&#123;num&#125;nd” 这将打印： this is the 2nd 四、环境变量由export关键字处理过的变量叫做环境变量。我们不对环境变量进行讨论，因为通常情况下仅仅在登录脚本中使用环境变量。 五、Shell命令和流程控制在shell脚本中可以使用三类命令： Unix 命令:虽然在shell脚本中可以使用任意的unix命令，但是还是有一些相对更常用的命令。这些命令通常是用来进行文件和文字操作的。常用命令语法及功能1234567891011121314151617181920212223echo “some text”: 将文字内容打印在屏幕上ls: 文件列表wc –l filewc -w filewc -c file: 计算文件行数计算文件中的单词数计算文件中的字符数cp sourcefile destfile: 文件拷贝mv oldname newname : 重命名文件或移动文件rm file: 删除文件grep ‘pattern’ file: 在文件内搜索字符串比如：grep ’searchstring’ file.txtcut -b colnum file: 指定欲显示的文件内容范围，并将它们输出到标准输出设备比如：输出每行第5个到第9个字符cut -b5-9 file.txt千万不要和cat命令混淆，这是两个完全不同的命令cat file.txt: 输出文件内容到标准输出设备（屏幕）上file somefile: 得到文件类型read var: 提示用户输入，并将输入赋值给变量sort file.txt: 对file.txt文件中的行进行排序uniq: 删除文本文件中出现的行列比如： sort file.txt | uniqexpr: 进行数学运算Example: add 2 and 3expr 2 “+” 3find: 搜索文件比如：根据文件名搜索find . -name filename -printtee: 将数据输出到标准输出设备(屏幕) 和文件比如：somecommand | tee outfilebasename file: 返回不包含路径的文件名比如： basename /bin/tux将返回 tuxdirname file: 返回文件所在路径比如：dirname /bin/tux将返回 /binhead file: 打印文本文件开头几行tail file : 打印文本文件末尾几行sed: Sed是一个基本的查找替换程序。可以从标准输入（比如命令管道）读入文本，并将结果输出到标准输出（屏幕）。该命令采用正则表达式（见参考）进行搜索。不要和shell中的通配符相混淆。比如：将linuxfocus替换为 LinuxFocus ：cat text.file | sed ’s/linuxfocus/LinuxFocus/’ &gt;newtext.fileawk: awk 用来从文本文件中提取字段。缺省地，字段分割符是空格，可以使用-F指定其他分割符。catfile.txt | awk -F, ‘&#123;print $1 “,” $3&#125;’这里我们使用“，”作为字段分割符，同时打印第一个和第三个字段。如果该文件内容如下： Adam Bor, 34, IndiaKerryMiller, 22, USA命令输出结果为：Adam Bor, IndiaKerry Miller, USA 概念: 管道, 重定向和 backtick这些不是系统命令，但是他们真的很重要。1.管道(|)—–将一个命令的输出作为另外一个命令的输入。grep “hello” file.txt | wc -l在file.txt中搜索包含有”hello”的行并计算其行数。在这里grep命令的输出作为wc命令的输入。当然您可以使用多个命令。2.重定向—–将命令的结果输出到文件，而不是标准输出（屏幕）。3.&gt;—– 写入文件并覆盖旧文件4.&gt;&gt;—– 加到文件的尾部，保留旧文件内容。5.反短斜线—–使用反短斜线可以将一个命令的输出作为另外一个命令的一个命令行参数。命令：1find . -mtime -1 -type f -print 用来查找过去24小时（-mtime –2则表示过去48小时）内修改过的文件。如果您想将所有查找到的文件打一个包，则可以使用以下linux 脚本：123#!/bin/sh# The ticks are backticks (`) not normal quotes (‘):tar -zcvf lastmod.tar.gz `find . -mtime -1 -type f -print` 流程控制if“if” 表达式 如果条件为真则执行then后面的部分：1234567if ….; then….elif ….; then….else….fi 大多数情况下，可以使用测试命令来对条件进行测试。比如可以比较字符串、判断文件是否存在及是否可读等等… 通常用” [ ] “来表示条件测试。注意这里的空格很重要。要确保方括号的空格。[ -f “somefile” ] ：判断是否是一个文件[ -x “/bin/ls” ] ：判断/bin/ls是否存在并有可执行权限[ -n “$var” ] ：判断$var变量是否有值[ “$a” = “$b” ] ：判断$a和$b是否相等执行man test可以查看所有测试表达式可以比较和判断的类型。直接执行以下脚本：123456#!/bin/shif [ “$SHELL” = “/bin/bash” ]; thenecho “your login shell is the bash (bourne again shell)”elseecho “your login shell is not bash but $SHELL”fi 变量$SHELL包含了登录shell的名称，我们和/bin/bash进行了比较。快捷操作符熟悉C语言的朋友可能会很喜欢下面的表达式：1[ -f “/etc/shadow” ] &amp;&amp; echo “This computer uses shadow passwors” 这里 &amp;&amp; 就是一个快捷操作符，如果左边的表达式为真则执行右边的语句。您也可以认为是逻辑运算中的与操作。上例中表示如果/etc/shadow文件存在则打印” This computer uses shadow passwors”。同样或操作(||)在shell编程中也是可用的。这里有个例子：12345#!/bin/shmailfolder=/var/spool/mail/james[ -r “$mailfolder” ]‘ ‘&#123; echo “Can not read $mailfolder” ; exit 1; &#125;echo “$mailfolder has mail from:”grep “^From ” $mailfolder 该脚本首先判断mailfolder是否可读。如果可读则打印该文件中的”From” 一行。如果不可读则或操作生效，打印错误信息后脚本退出。这里有个问题，那就是我们必须有两个命令：◆打印错误信息◆退出程序我们使用花括号以匿名函数的形式将两个命令放到一起作为一个命令使用。一般函数将在下文提及。不用与和或操作符，我们也可以用if表达式作任何事情，但是使用与或操作符会更便利很多。 casecase :表达式可以用来匹配一个给定的字符串，而不是数字。123case … in…) do something here ;;esac 让我们看一个例子。 file命令可以辨别出一个给定文件的文件类型，比如：1file lf.gz 这将返回：12lf.gz: gzip compressed data, deflated, original filename,last modified: Mon Aug 27 23:09:18 2001, os: Unix 我们利用这一点写了一个叫做smartzip的脚本，该脚本可以自动解压bzip2, gzip 和zip 类型的压缩文件：1234567891011#!/bin/shftype=`file “$1″`case “$ftype” in“$1: Zip archive”*)unzip “$1” ;;“$1: gzip compressed”*)gunzip “$1” ;;“$1: bzip2 compressed”*)bunzip2 “$1” ;;*) echo “File $1 can not be uncompressed with smartzip”;;esac 您可能注意到我们在这里使用了一个特殊的变量$1。该变量包含了传递给该程序的第一个参数值。也就是说，当我们运行：smartzip articles.zip$1 就是字符串 articles.zip selsectselect 表达式是一种bash的扩展应用，尤其擅长于交互式使用。用户可以从一组不同的值中进行选择。1234select var in … ; dobreakdone…. now $var can be used …. 下面是一个例子：123456#!/bin/shecho “What is your favourite OS?”select var in “Linux” “Gnu Hurd” “Free BSD” “Other”; dobreakdoneecho “You have selected $var” 下面是该脚本运行的结果：1234567What is your favourite OS?1) Linux2) Gnu Hurd3) Free BSD4) Other#? 1You have selected Linux loopwhile-loop 将运行直到表达式测试为真。will run while the expression that we test for is true.关键字”break” 用来跳出循环。而关键字”continue”用来不执行余下的部分而直接跳到下一个循环。123while …; do….done for-loop表达式查看一个字符串列表 (字符串用空格分隔) 然后将其赋给一个变量：123for var in ….; do….done 在下面的例子中，将分别打印ABC到屏幕上：1234#!/bin/shfor var in A B C ; doecho “var is $var”done 下面是一个更为有用的脚本showrpm，其功能是打印一些RPM包的统计信息：123456789101112#!/bin/sh# list a content summary of a number of RPM packages# USAGE: showrpm rpmfile1 rpmfile2 …# EXAMPLE: showrpm /cdrom/RedHat/RPMS/*.rpmfor rpmpackage in $*; doif [ -r “$rpmpackage” ];thenecho “=============== $rpmpackage ==============”rpm -qi -p $rpmpackageelseecho “ERROR: cannot read file $rpmpackage”fidone 这里出现了第二个特殊的变量$，该变量包含了所有输入的命令行参数值。如果您运行showrpm openssh.rpm w3m.rpm webgrep.rpm此时 $ 包含了 3 个字符串，即openssh.rpm, w3m.rpm and webgrep.rpm. 引号在向程序传递任何参数之前，程序会扩展通配符和变量。这里所谓扩展的意思是程序会把通配符（比如）替换成合适的文件名，它变量替换成变量值。为了防止程序作这种替换，您可以使用引号：让我们来看一个例子，假设在当前目录下有一些文件，两个jpg文件， mail.jpg 和tux.jpg。 1.2 编译SHELL脚本1#ch#!/bin/sh mod +x filename cho *.jpg/filename 来执行您的脚本。这将打印出”mail.jpg tux.jpg”的结果。引号 (单引号和双引号) 将防止这种通配符扩展：123#!/bin/shecho “*.jpg”echo ‘*.jpg’ 这将打印”*.jpg” 两次。单引号更严格一些。它可以防止任何变量扩展。双引号可以防止通配符扩展但允许变量扩展。1234#!/bin/shecho $SHELLecho “$SHELL”echo ‘$SHELL’ 运行结果为：123/bin/bash/bin/bash$SHELL 最后，还有一种防止这种扩展的方法，那就是使用转义字符——反斜杆：12echo *.jpgecho $SHELL' 这将输出：12*.jpg$SHELL Here documents当要将几行文字传递给一个命令时，here documents（译者注：目前还没有见到过对该词适合的翻译）是一种不错的方法。对每个脚本写一段帮助性的文字是很有用的，此时如果我们四有那个 here documents就不必用echo函数一行行输出。 一个 “Here document” 以12345678910shift by 2–) shift;break;; # end of options-*) echo “error: no such option $1. -h for help”;exit 1;;*) break;;esacdoneecho “opt_f is $opt_f”echo “opt_l is $opt_l”echo “first arg is $1”echo “2nd arg is $2” 您可以这样运行该脚本：1cmdparser -l hello -f — -somefile1 somefile2 返回的结果是：1234opt_f is 1opt_l is hellofirst arg is -somefile12nd arg is somefile2 这个脚本是如何工作的呢？脚本首先在所有输入命令行参数中进行循环，将输入参数与case表达式进行比较，如果匹配则设置一个变量并且移除该参数。根据unix系统的惯例，首先输入的应该是包含减号的参数.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络爬虫URL简介]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F03%2F%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%ABURL%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[一、网络爬虫的定义网络爬虫，即Web Spider，是一个很形象的名字。 把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。网络蜘蛛是通过网页的链接地址来寻找网页的。 从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址， 然后通过这些链接地址寻找下一个网页，这样一直循环下去，直到把这个网站所有的网页都抓取完为止。 如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。 这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。 网络爬虫的基本操作是抓取网页。 那么如何才能随心所欲地获得自己想要的页面？ 我们先从URL开始。 二、浏览网页的过程抓取网页的过程其实和读者平时使用IE浏览器浏览网页的道理是一样的。 比如说你在浏览器的地址栏中输入www.baidu.com 这个地址。 打开网页的过程其实就是浏览器作为一个浏览的“客户端”，向服务器端发送了 一次请求，把服务器端的文件“抓”到本地，再进行解释、展现。 HTML是一种标记语言，用标签标记内容并加以解析和区分。 浏览器的功能是将获取到的HTML代码进行解析，然后将原始的代码转变成我们直接看到的网站页面。 三、URI和URL的概念和举例简单的来讲，URL就是在浏览器端输入的http://www.baidu.com 这个字符串。 在理解URL之前，首先要理解URI的概念。 什么是URI？ Web上每种可用的资源，如 HTML文档、图像、视频片段、程序等都由一个通用资源标志符(Universal Resource Identifier， URI)进行定位。 URI通常由三部分组成： 访问资源的命名机制； 存放资源的主机名； 资源自身 的名称，由路径表示。 四、URL的理解和举例URL是URI的一个子集。它是Uniform Resource Locator的缩写，译为“统一资源定位符”。 通俗地说，URL是Internet上描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上。 采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。 URL的一般格式为(带方括号[]的为可选项)： protocol :// hostname[:port] / path / [;parameters][?query]#fragment URL的格式由三部分组成： 第一部分是协议(或称为服务方式)。 第二部分是存有该资源的主机IP地址(有时也包括端口号)。 第三部分是主机资源的具体地址，如目录和文件名等。 第一部分和第二部分用“://”符号隔开， 第二部分和第三部分用“/”符号隔开。 第一部分和第二部分是不可缺少的，第三部分有时可以省略。 五、URL和URI简单比较URI属于URL更低层次的抽象，一种字符串文本标准。 换句话说，URI属于父类，而URL属于URI的子类。URL是URI的一个子集。 URI的定义是：统一资源标识符； URL的定义是：统一资源定位符。 二者的区别在于，URI表示请求服务器的路径，定义这么一个资源。 而URL同时说明要如何访问这个资源（http://）。 两个URL的小例子。 HTTP协议的URL示例： 使用超级文本传输协议HTTP，提供超级文本信息服务的资源。 例：http://www.peopledaily.com.cn/channel/welcome.htm 其计算机域名为www.peopledaily.com.cn。 超级文本文件(文件类型为.html)是在目录 /channel下的welcome.htm。 这是中国人民日报的一台计算机。 例：http://www.rol.cn.net/talk/talk1.htm 其计算机域名为www.rol.cn.net。 超级文本文件(文件类型为.html)是在目录/talk下的talk1.htm。 这是瑞得聊天室的地址，可由此进入瑞得聊天室的第1室。 文件的URL 用URL表示文件时，服务器方式用file表示，后面要有主机IP地址、文件的存取路 径(即目录)和文件名等信息。 有时可以省略目录和文件名，但“/”符号不能省略。 例：file://ftp.yoyodyne.com/pub/files/foobar.txt 上面这个URL代表存放在主机ftp.yoyodyne.com上的pub/files/目录下的一个文件，文件名是foobar.txt。 例：file://ftp.yoyodyne.com/pub 代表主机ftp.yoyodyne.com上的目录/pub。 例：file://ftp.yoyodyne.com/ 代表主机ftp.yoyodyne.com的根目录。 爬虫最主要的处理对象就是URL，它根据URL地址取得所需要的文件内容，然后对它 进行进一步的处理。 因此，准确地理解URL对理解网络爬虫至关重要。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo插件]]></title>
    <url>%2F%2Fblog%2F2017%2F02%2F01%2Fhexo%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[mkdir hexo #创建一个文件夹 cd hexo 安装hexonpm install -g hexo-clinpm install hexo –save 部署Hexo：在Git shell 中输入hexo init 安装Hexo 插件：自动生成sitemap,Rss，部署到git，字数统计等，建议全部安装 npm install -g hexo-clinpm install hexo –savenpm install hexo-generator-index –savenpm install hexo-generator-archive –savenpm install hexo-generator-category –savenpm install hexo-generator-tag –savenpm install hexo-server –savenpm install hexo-deployer-git –savenpm install hexo-deployer-heroku –savenpm install hexo-deployer-rsync –savenpm install hexo-deployer-openshift –savenpm install hexo-renderer-marked@0.2 –savenpm install hexo-renderer-stylus@0.2 –savenpm install hexo-generator-feed@1 –savenpm install hexo-generator-sitemap@1 –savenpm install hexo-generator-searchdb –savenpm install hexo-generator-feed –savenpm install hexo-generator-seo-friendly-sitemap –savenpm install hexo-wordcount –save]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-设置阅读全文]]></title>
    <url>%2F%2Fblog%2F2017%2F01%2F28%2FHexo-%E8%AE%BE%E7%BD%AE%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87.html</url>
    <content type="text"><![CDATA[最近使用Hexo搭建了自己的博客，并且使用了简洁但是强大的NexT主题。这里介绍一下NexT主题下设置在首页显示一篇文章的简介，在简介后面提供一个链接阅读全文来进入文章的详情页。 方式一在文章中使用&lt; !–more–&gt; 手动进行截断这种方法可以根据文章的内容，自己在合适的位置添加 &lt; !–more–&gt; 标签，使用灵活，也是Hexo推荐的方法。 方式二在文章中的front-matter中添加description，并提供文章摘录这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。 方式三自动形成摘要，在主题配置文件中添加默认截取的长度为 150 字符，可以根据需要自行设定 auto_excerpt: enable: true length: 150 建议使用 &lt; !– more –&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F%2Fblog%2F2017%2F01%2F25%2Fhexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content type="text"><![CDATA[hexo安装与升级npm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 服务器命令hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令 文件生成及部署hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #将.deploy目录部署到GitHub 监视文件变动hexo generate --watch #监视文件变动 命令简化hexo n == hexo new #新建文章hexo p == hexo publish #草稿hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署hexo generate --deploy hexo deploy --generate #作用相同 命令详解hexo newhexo new &quot;学习笔记 六&quot; 新建一篇标题为 学习笔记 六 的文章，因为标题里有空格，所以加上了引号。 文章标题可以在对应 md 文件里改，新建时标题可以写的简单些。 hexo new pagehexo new page aboutme 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/ 标题可以为中文，但一般习惯用英文； 页面标题和文章一样可以随意修改； 页面不会出现在首页文章列表和归档中，也不支持设置分类和标签。 hexo cleanhexo clean 清除缓存文件 db.json 和已生成的静态文件 public 。 网站显示异常时可以执行这条命令试试。 hexo ghexo g 生成网站静态文件到默认设置的 public 文件夹。 便于查看网站生成的静态文件或者手动部署网站； 如果使用自动部署，不需要先执行该命令； hexo g 是 hexo generate 的缩写，命令效果一致。 hexo shexo s 启动本地服务器，用于预览主题。默认地址： http://localhost:4000/ hexo s 是 hexo server 的缩写，命令效果一致； 预览的同时可以修改文章内容或主题代码，保存后刷新页面即可； 对 Hexo 根目录_config.yml的修改，需要重启本地服务器后才能预览效果。 hexo dhexo d 自动生成网站静态文件，并部署到设定的仓库； hexo d 是hexo deploy的缩写，命令效果一致。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
