<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Czs--从此蜕变</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://CzsGit.github.io/"/>
  <updated>2022-07-14T01:58:42.807Z</updated>
  <id>https://CzsGit.github.io/</id>
  
  <author>
    <name>Czs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python spider get方法的封装</title>
    <link href="https://CzsGit.github.io//blog/2018/07/22/Python-spider-get%E6%96%B9%E6%B3%95%E7%9A%84%E5%B0%81%E8%A3%85.html"/>
    <id>https://CzsGit.github.io//blog/2018/07/22/Python-spider-get方法的封装.html</id>
    <published>2018-07-22T14:49:14.000Z</published>
    <updated>2022-07-14T01:58:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>大家经常使用Python3的urllib库进行get请求，得到数据，来封装爬虫的行为。下面封装了一个方法供大家参考使用：<br><a id="more"></a><br>这里比较规范的使用了工程化的思想，考虑了日志的编写；爬虫发送get请求时，则考虑了UA等http request head部分的设置；并且支持代理服务器的信息处理；返回的状态码不是200时的处理；并且考虑了超时问题，及网页的编码问题</p><pre><code>import sysimport loggingimport urllibimport randomimport timeimport sockettimeout = 15    socket.setdefaulttimeout(timeout)#这里对整个socket层设置超时时间。后续文件中如果再使用到socket，不必再设置 # 创建日志的实例logger = logging.getLogger(&quot;basicSpider&quot;)# 定制Logger的输出格式formatter = logging.Formatter(&quot;%(asctime)s %(levelname)s %(message)s&quot;)# 创建日志:文件日志，终端日志file_handler = logging.FileHandler(&apos;basicSpider.log&apos;)file_handler.setFormatter(formatter)consle_handler = logging.StreamHandler(sys.stdout)consle_handler.setFormatter(formatter)# 设置默认的日志级别logger.setLevel(logging.INFO)# 把文件日志和终端日志添加到日志处理器中logger.addHandler(file_handler)logger.addHandler(consle_handler)PROXY_RANGE_MIN = 1PROXY_RANGE_MAX = 10PROXY_RANGE = 10NUM = 10def downloadHtml(url, headers=[],                 proxy={}, num_retries=NUM,                 timeout=NUM, decodeInfo=&quot;utf-8&quot;):    &quot;&quot;&quot;    爬虫的get请求，考虑了UA等http request head部分的设置；    支持代理服务器的信息处理；    返回的状态码不是200，这时怎么处理；    考虑超时问题，及网页的编码问题    &quot;&quot;&quot;    html = None    if num_retries &lt;= 0:        return html    # 一般来说，使用UA池和Proxy池相结合的方式来访问某个页面，会    #更加的不容易被反爬。    # 动态的调整代理服务器的使用策略    if random.randint(PROXY_RANGE_MIN,PROXY_RANGE_MAX) &gt; PROXY_RANGE:         logger.info(&quot;No Proxy&quot;)        proxy = None     proxy_handler = urllib.request.ProxyHandler(proxy)    # 替换handler，以实现可以处理Proxy    opener = urllib.request.build_opener(proxy_handler)    # 把opener装载进urllib库中，准备使用    opener.addheaders = headers    urllib.request.install_opener(opener)    try:        response = urllib.request.urlopen(url)        html = response.read().decode(decodeInfo)    except UnicodeDecodeError:        logger.error(&quot;UnicodeDecodeError&quot;)    except urllib.error.URLError or \           urllib.error.HTTPError as e:               logger.error(&quot;urllib error %s&quot;%e.__str__)               if hasattr(e,&apos;code&apos;) and 400 &lt;= e.code &lt; 500:                   logger.error(&quot;Client Error %d&quot;%e.code) # 客户端问题，通过分析日志来跟踪               elif hasattr(e,&apos;code&apos;) and 500 &lt;= e.code &lt; 600:                   html = downloadHtml(url,                                       headers,                                       proxy,                                       timeout,                                       decodeInfo,                                       num_retries-1)                   time.sleep(PROXY_RANGE)# 休息的时间可以自己定义一个策略    except Exception as e:       logger.error(&quot;Download error reson is %s&quot;%e.reson)       urllib.request.close()#记得要关闭                 return htmlif __name__ == &quot;__main__&quot;:    url = &quot;http://www.sina.com.cn&quot;    headers = [(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.181 Safari/537.36&quot;)]     # 注意：这里的UA和Proxy可以根据自己的需求来改变，也可以对它们使用池来随机取值    proxy = {&quot;http&quot;:&quot;182.129.243.84:9000&quot;}    print(downloadHtml(url, headers, proxy))logger.removeHandler(file_handler)logger.removeHandler(consle_handler) </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家经常使用Python3的urllib库进行get请求，得到数据，来封装爬虫的行为。下面封装了一个方法供大家参考使用：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>余弦相似度和欧氏距离的区别</title>
    <link href="https://CzsGit.github.io//blog/2018/07/16/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6%E5%92%8C%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>https://CzsGit.github.io//blog/2018/07/16/余弦相似度和欧氏距离的区别.html</id>
    <published>2018-07-16T13:46:57.000Z</published>
    <updated>2022-07-14T01:58:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>Basic Vector Space Search Engine Theory</p><p>LA2600– January2, 2004 - presented by Vidiot<br>Overview:<br>A Vector Space Search Engine uses very simple techniques from matrix algebra to compare documents based on word frequency.<br>The first major component of a vector space search engine is the concept of a term space. Simply put, a term space consists of every unique word that<br>appears in a collection of documents.<br><a id="more"></a><br>The second major component of a vector space search engine is term counts.<br>Term counts are simply records of how many times each term occurs in an<br>individual document. This is usually represented as a table, as in the illustration below.</p><p>By using the term space as a coordinate space, and the term counts as<br>coordinates within that space, we can create a vectorfor each document. In<br>order to understand how we create these vectors, let’s look at a simple example. You’re probably familiar with Cartesian Coordinates; plotting points along X, Y,<br>and Z axes. Similarly, in the case of a term space containing three unique terms we would refer to these axes as the term1, term2, and term3axes. (In vector<br>space search theory these axes are usually referred to as dimensions.) By<br>counting how many times each term appears in a document, and plotting the<br>coordinates along each term dimension, we can determine a point in the term<br>spacethat corresponds to the document. Using this point we can then create a<br>vector for the document back to the origin.</p><p>Once we have plotted the vector of a document through the term space, we can then calculate the magnitude of the vector. Think of the magnitude as the length of the line between the documents point in the term space and the origin of the<br>term space(at coordinates(0,0,0) in our example). These vector magnitudes will allow us to compare documents by calculating the cosign of the angle between<br>them. For example, identical documents will have a cosign of1, documents<br>containing similar terms will have positive decimal cosigns, and documents with<br>nothing in common will have cosigns of zero.</p><p>A Simple Example:<br>In this tutorial we’ll go through the entire indexing and search process using a simple three dimensional example that is easy to envision.<br>To begin, lets assume we have a collection of three documents. Each document contains combinations of the words cat, dog, and mouse. The words cat, dog,<br>and mouse are the term space. Thus we can say that each document has<br>coordinates along the cat, dog, and mousedimensions. These coordinates are</p><p>two dimensions, so the formula would be:a2+b2+c2=d21,000 unique words, and thus 1,000 dimensions, the formula would continue to be a2+b2+c2+d2+e2…etc., 995 more times until we reach our answer.<strong><strong><strong>__</strong></strong></strong>Q = (02)+(02)+(12)= 0+0+1 = 1=12</p><p>determined by how many times each term appears in the document. For<br>example, document 1 below would have a “cat-dog-mouse vector” of (3,1 ,4).</p><p>We calculate the magnitude of the vector for each document using the Pythagorean<br>Theorem, but in this case we have more than</p><hr><p>V1  =  (32)+(12)+(42)= 9+1 +16= 26=5.09901</p><hr><p>V2  =  (12)+(22)+(52) =  1 +4+25= 30=5.47722</p><hr><p>V3  =  (22)+(32)+(02)= 4+9+0  =  15=3.87298<br>NOTE: The two vertical bars on each side of the vector variable mean “the magnitude of”.</p><p>Note that the Pythagorean Theorem formula will continue to apply no matter how many dimensions we are working with. For example, if we had a term space with</p><p>Also, the astute observer may have noticed that different documents can have the exact same vector magnitudes.  For example, two different documents with vectors of (1,2,3) and (3,2,1) would both have a vector magnitude of 3.74165. This is not a contradiction. As we will see, relevancy scores of documents are based on the dimensionality of the query term that is searched for, thus documents with identical vector magnitudes can return very different query results.  In other words, just because two lines are the same length, it doesn’t necessarily mean that they are pointing to the same angle within the term space.<br>Querying :<br>To query the document collection index, we project the vector of our query into the vector space, and then calculate the cosign of the angle between the query and each of the other documents in the collection.  In English, this means we project the query vector into the vector space, and then see what other document vectors are nearby.<br>For example, if the query term is “mouse”, then the “cat-dog-mouse vector” would be (0,0,1). The magnitude of our query vector would then be:</p><p>3</p><p>NOTE: A simple optimization while coding is to check if the query term is in the term<br>space, and if so, then  Q  will always = 1 , but this only works with a single search<br>term. For multiple search terms, count how many are within the term space, and take the square root of the count. Because query terms are not represented as values less than 1 , the solution to  Q  will always be the square root of a whole number. But this assumes that each term appears only once in each query, which is not necessarily a<br>good assumption because of word stemming which I will discuss shortly.<br>To calculate the cosign between the query and a document vector, we divide the Dot Productof the query vector and the document vector, by the magnitude of the query vector multiplied by the magnitude of the document vector.</p><p>Q * V1_ Q x V1<br>The Dot Productis the sum of the term counts for each document and the<br>corresponding query term counts multiplied together.  For example, if we were to search for the term “mouse”, the coordinates for the Query would be (0,0,1)<br>because the words cat and dog do not appear and the word mouse appears<br>once is the third dimension of the term space. Document 1 in our example<br>collection would have a vector of (3,1 ,4) based on the term counts listed in the<br>table above. If we wanted to calculate the Dot Product between the Query and<br>Document 1 we would make the following calculation:</p><p>Now we divide the Dot Product of 4, by the product of the query and document magnitudes, to get the cosine value. As we saw earlier the magnitude of the<br>vector of Document 1 is 5.09901 , and the magnitude of the Query vector = 1 . Thus the cosign value is 4 divided by 5.09901 .<br>Let’s try it out. The cosign of the angle between the query for “mouse”, and Document 1 would be calculated by:</p><p>Q * V1 Q  x  V1= (0x3)+(0x1)+(1x4)=4= 0.784461x 5.09901         5.09901</p><p>NOTE: If a document doesn’t contain any relevant search terms from the query, the Dot Productwill be zero, because zero divided by any value is still zero, thus the cosign will also be zero. This is good to remember while writing efficient code.<br>If we performed this calculation for the other two documents we would get the following cosigns:</p><p>orthogonal in the term space and are not related. Collection Indexing Processoptimized to make the indexing process more efficient.As an example, let’s assume we want to index a small website.4</p><p>Doc 1 = 0.78446 Doc 2 = 0.91287 Doc 3 = 0.00000<br>By arranging the documents in descending order according to the cosigns, as so:<br>Doc 2 = 0.91287 Doc 1 = 0.78446 Doc 3 = 0.00000<br>…we can see that document 2 is the most relevant to the query of “mouse”, and a quick glance at our term counts table above will confirm this. Document 1 is<br>slightly less relevant, and Document 3 is completely irrelevant, because it doesn’t contain any instances of the word “mouse”.<br>An easy way to think of this is that the closer the cosign value is to 1 , the more relevant the document is. If the cosign is zero, then the documents are</p><p>The process of indexing a collection is specific to the type of documents being<br>indexed. Vector Space search technology can be used on any type information that can be represented in a structured fashion, so it will work equally well on<br>text, images, cryptographic keys, or even DNA. However, custom parsers must be constructed to handle the information in a regulated fashion, and can often be</p><p>First each HTML document must be pre-processed, and then indexed as part of a collection. (Collections can only be indexed as a whole. Adding additional files to a collection after it has been indexed changes the dimensionality of the term<br>space and negates the stored document vector magnitudes.)<br>We begin by stripping out all the HTML content because is contains no semantic content. We can also strip out any formatting such as line breaks and carriage returns so that we are left with a simple block of text.</p><p>Next, we remove stop words from the text. Stop words are words that occur<br>commonly in the English language, but don’t add any semantic value to the text as a whole. For example, words like “the”, “and”, “of”, and “or” are irrelevant to<br>the actual semantic meaning of the document but would artificially enlarge the<br>term space, and thus the processing time, if they were left in. Also adverbs such as “quickly” (or anything typically ending in “ly”) can be removed because they<br>don’t add any additional semantic value.</p><p>Remove Stop WordsStem Termsexperiment to find the optimal partitions within particular data.Vector Space Search Engine Limitations:Despite how cool Vector Space search technology is, it does have some serious limitations.5</p><p>Next, we stemthe remaining terms in the document. Stemming consists of<br>reducing English word to their root word forms. For example, the words “runner”, “running”, and “runs” would all be stemmed to the word “run.” The Porter<br>Stemming Algorithm is typically used for this purpose. This further reduces the<br>term space while maintaining semantic content.</p><p>After we have finished with these three steps we are left with (hopefully) the<br>minimal number of terms required to contain the semantic meaning of the original document.<br>No we can begin indexing the collection by building the term space and calculating the vector magnitude of each document.</p><p>Step 1 – Strip out HTML, punctuation, and line breaks to leave only blocked textual<br>content.<br>Step 2 – Remove stop words (such as “the”) to reduce the size of the term space.<br>Step 3 – Stem the remaining terms to further reduce the size of the term space while<br>maintaining semantic content.  For example, “runner” and “running” will both be<br>stemmed to “run”. The Porter stemming algorithm is commonly used for this purpose. Step 4A – Populate the term space with one unique instance of each term, from every<br>document, that spans across the entire collection so that all possible terms are included. Store the results.<br>Step 4B – Count and record how many times each relevant term appears in each<br>document.<br>Step 4C – Calculate and record the vector magnitude,  Vn , for each document.<br>NOTE: It is important to keep in mind that how the parser divides up information will affect the search results. For example, if you were indexing the contents of a book, the indexing time and search results would differ greatly depending on<br>whether you broke the text up by chapter, page, or paragraph. You will need to</p><p>First, it is VERY calculation intensive, and therefore quite slow. Because of all<br>the floating-point mathematics, it requires lots and lots of processor time, which<br>kills performance. High performance requires large systems with code optimized to run calculations exclusively in RAM. Hopefully, this will become less of a<br>barrier as processor speeds continue to increase.</p><p>building a vector space search engine including open source PERL code. •  <a href="http://www.chuggnutt.com/stemmer.php" target="_blank" rel="noopener">http://www.chuggnutt.com/stemmer.php</a> - Open source implementation ofthe Porter stemming algorithm in PHP•  <a href="http://www.nitle.org/semantic_search.php" target="_blank" rel="noopener">http://www.nitle.org/semantic_search.php</a> - Open source Latent SemanticIndexing package written in Perl. Very much in Beta, not yet suitable forproduction.•  <a href="http://lsi.argreenhouse.com/-" target="_blank" rel="noopener">http://lsi.argreenhouse.com/-</a> Closed source online Latent SemanticIndexing demo by Telecordia Technologies•   “Using LinearAlgebrafor Information Retrieval” - Berry, M. W.; Dumais,S. T.; and O’Brien, G. W. 1995.•  “Indexing by latent semantic analysis.” Journal of the Society forInformation Science, 41 (6), 391-407. — first technical Latent SemanticIndexing paper; good background.•  “Enhancing Performance in Latent Semantic Indexing Retrieval” - SusanDumais, TM-ARH-017527 Technical Report, Bellcore, 19906</p><p>Second, dynamic collections will (usually) require re-indexing each time a new document is added. This is because every time you introduce a new term into the term space, you are adding another dimension to the matrix, and all existing documents must be re-indexed so that their vectors are relevant to the new<br>dimensionality. This is perhaps the most serious barrier to the widespread<br>adoption of this technology because it makes real time availability of search<br>results next to impossible.<br>Third, it requires additional mathematical transformation of the collection matrix in order to detect additional connections between documents with Latent Semantic Indexing. LSI allows us to find additional connections between documents on a semantic level. It is outside the scope of this document, but it is an important<br>next-step in Vector Space search technology, and another barrier to real time<br>usability.<br>Resources and Additional Reading<br>•  <a href="http://www.perl.com/pub/a/2003/02/19/engine.html" target="_blank" rel="noopener">http://www.perl.com/pub/a/2003/02/19/engine.html</a> - Excellent article about</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Basic Vector Space Search Engine Theory&lt;/p&gt;
&lt;p&gt;LA2600– January2, 2004 - presented by Vidiot&lt;br&gt;Overview:&lt;br&gt;A Vector Space Search Engine uses very simple techniques from matrix algebra to compare documents based on word frequency.&lt;br&gt;The first major component of a vector space search engine is the concept of a term space. Simply put, a term space consists of every unique word that&lt;br&gt;appears in a collection of documents.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Verification" scheme="https://CzsGit.github.io/categories/Verification/"/>
    
    
      <category term="Verification" scheme="https://CzsGit.github.io/tags/Verification/"/>
    
  </entry>
  
  <entry>
    <title>info函数的封装</title>
    <link href="https://CzsGit.github.io//blog/2018/05/22/info%E5%87%BD%E6%95%B0%E7%9A%84%E5%B0%81%E8%A3%85.html"/>
    <id>https://CzsGit.github.io//blog/2018/05/22/info函数的封装.html</id>
    <published>2018-05-22T14:01:34.000Z</published>
    <updated>2022-07-14T01:58:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>大家在使用Python help或者info查看信息时，有时显得很不灵活，冗长并且全英文（可能对一些英文不太好的人而言不方便）。于是，我就封装了下面一个小方法，可以实现将模块或者函数的名称和doc string的中文解释对应上。这里的中文解释来源于有道词典的网络API数据抓取。<br><a id="more"></a></p><h5 id="本代码推荐使用使用环境是Python3-5及以上版本，我测试的是Anaconda3-5-1-0-Windows-x86-64-exe版本；"><a href="#本代码推荐使用使用环境是Python3-5及以上版本，我测试的是Anaconda3-5-1-0-Windows-x86-64-exe版本；" class="headerlink" title="本代码推荐使用使用环境是Python3.5及以上版本，我测试的是Anaconda3-5.1.0-Windows-x86_64.exe版本；"></a>本代码推荐使用使用环境是Python3.5及以上版本，我测试的是Anaconda3-5.1.0-Windows-x86_64.exe版本；</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTInfo</span><span class="params">(key)</span>:</span>   </span><br><span class="line">    <span class="comment"># 通过抓包的方式获取的url，并不是浏览器上显示的url</span></span><br><span class="line">    url = <span class="string">"http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule&amp;smartresult=ugc&amp;sessionFrom=null"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 完整的headers</span></span><br><span class="line">    headers = &#123;</span><br><span class="line">            <span class="string">"Accept"</span> : <span class="string">"application/json, text/javascript, */*; q=0.01"</span>,</span><br><span class="line">            <span class="string">"X-Requested-With"</span> : <span class="string">"XMLHttpRequest"</span>,</span><br><span class="line">            <span class="string">"User-Agent"</span>: <span class="string">"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:45.0) Gecko/20100101 Firefox/45.0"</span>,</span><br><span class="line">            <span class="string">"Content-Type"</span> : <span class="string">"application/x-www-form-urlencoded; charset=UTF-8"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    formdata = &#123;</span><br><span class="line">    <span class="string">"i"</span>:key,</span><br><span class="line">    <span class="string">"from"</span>:<span class="string">"auto"</span>,</span><br><span class="line">    <span class="string">"to"</span>:<span class="string">"auto"</span>,</span><br><span class="line">    <span class="string">"smartresult"</span>:<span class="string">"dict"</span>,</span><br><span class="line">    <span class="string">"client"</span>:<span class="string">"fanyideskweb"</span>,</span><br><span class="line">    <span class="string">"salt"</span>:<span class="string">"1511219405946"</span>,</span><br><span class="line">    <span class="string">"sign"</span>:<span class="string">"f8965f67a1d3eee8a69ddf8ccc5f582b"</span>,</span><br><span class="line">    <span class="string">"doctype"</span>:<span class="string">"json"</span>,</span><br><span class="line">    <span class="string">"version"</span>:<span class="string">"2.1"</span>,</span><br><span class="line">    <span class="string">"keyfrom"</span>:<span class="string">"fanyi.web"</span>,</span><br><span class="line">    <span class="string">"action"</span>:<span class="string">"FY_BY_REALTIME"</span>,</span><br><span class="line">    <span class="string">"typoResult"</span>:<span class="string">"false"</span></span><br><span class="line">    &#125;</span><br><span class="line">    data=bytes(parse.urlencode(formdata),encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment">#利用Request将headers，dict，data整合成一个对象传入urlopen</span></span><br><span class="line">    req = request.Request(url,data,headers,method=<span class="string">'POST'</span>)</span><br><span class="line">    response=request.urlopen(req)</span><br><span class="line">    info = response.read().decode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">    strRule = re.compile(<span class="string">'"tgt":(.*?)&#125;'</span>)</span><br><span class="line">    info2 = strRule.findall(info)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> info2:</span><br><span class="line">               i = i.replace(<span class="string">'"'</span>,<span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> info2[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(object, spacing=<span class="number">15</span>, collapse=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">     Print methods and doc strings. Take module, class, </span></span><br><span class="line"><span class="string">     dictionary, or string.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 遍历一遍object对象，把里面的可以被调用的方法提取出来</span></span><br><span class="line">    methodList = [method <span class="keyword">for</span> method <span class="keyword">in</span> dir(object) </span><br><span class="line">                  <span class="keyword">if</span> callable(getattr(object, method))]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 把要提取出来的方法以更好看的,多行变单行</span></span><br><span class="line">    <span class="comment">#collapse可以控制打印的信息是否换行</span></span><br><span class="line">    <span class="comment">#collapse = 1,并行</span></span><br><span class="line">    <span class="comment">#collapse = 0,保持原来的显示</span></span><br><span class="line">    processFunc = collapse <span class="keyword">and</span> (<span class="keyword">lambda</span> s:<span class="string">" "</span>.join(s.split())) <span class="keyword">or</span> (<span class="keyword">lambda</span> s:s)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 让左端打印的是方法名称，右端打印的是方法的doc名称</span></span><br><span class="line">    <span class="comment">#print('\n'.join(["%s %s"%(str(method.ljust(spacing)), </span></span><br><span class="line">    <span class="comment">#       processFunc(str(getattr(object, method).__doc__)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#      for method in methodList]))</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'\n'</span>.join([<span class="string">"%s %s"</span>%(str(method.ljust(spacing)), processFunc(getTInfo(str(getattr(object, method).__doc__)))) <span class="keyword">for</span> method <span class="keyword">in</span> methodList]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  测试</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">info(os.path)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家在使用Python help或者info查看信息时，有时显得很不灵活，冗长并且全英文（可能对一些英文不太好的人而言不方便）。于是，我就封装了下面一个小方法，可以实现将模块或者函数的名称和doc string的中文解释对应上。这里的中文解释来源于有道词典的网络API数据抓取。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://CzsGit.github.io//blog/2018/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/15/正则表达式.html</id>
    <published>2018-04-15T12:33:35.000Z</published>
    <updated>2022-07-14T01:58:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>正则表达式</p><p>动机<br>1.处理文本成为计算机常见工作之一<br>2.对文本内容的搜索提取是一项比较复杂困难的工作<br>3.为了快速方便处理上述问题，正则表达式技术诞生，逐渐被发展为一个被众多语言使用的独立技术<br><a id="more"></a><br>定义：即高级文本匹配模式，提供了搜索，替代等功能，本质是由一系列特殊符号和字符组成的字串<br>      这个字串即是正则表达式，这个表达式描述了字符和字符的重复行为，可以匹配一类特征的字符串</p><p>目标：<br>1.熟练使用正则表达式符号<br>2.正确的组合和理解一般的正则表达式<br>3.能够使用python操作正则表达式</p><p>正则表达式的特点<br>1.方便进行检索和修改<br>2.支持语言众多<br>3.灵活多样<br>4.mongo正则类型，django等框架作为url匹配，爬虫</p><p>正则表达式的使用<br>python—&gt;re模块 处理正则表达式</p><p>re.findall(pattern,string)<br>功能：使用正则表达式匹配字符串<br>参数：pattern 正则表达式<br>      string 目标字符串<br>返回值：一个列表，匹配到的所有内容</p><p>元字符（即正则表达式中有特殊含义的符号）</p><p>1.普通字符<br>元字符：abc<br>匹配规则：匹配响应的普通字符</p><p>2.或<br>元字符：|<br>匹配规则：匹配|两边任意一个正则表达式符合的情况<br>| 两侧不要有没用的空格</p><p>3.匹配单一字符<br>元字符：.<br>匹配规则：匹配除了换行之外的任意字符<br>f.o –&gt; foo fao f#o …</p><p>4.匹配开始位置<br>元字符： ^<br>匹配规则：匹配一个字符串的开始位置</p><p>5.匹配结束位置<br>元字符：$<br>匹配规则：匹配目标字符串的结束位置<br>py$ —&gt; hello.py</p><p>6.匹配重复<br>元字符：*<br>匹配规则：匹配前面的正则表达式重复0次或多次</p><p>7.匹配重复<br>元字符：+<br>匹配规则：匹配前面的正则表达式重复1次或多次<br>ab+ —&gt;ab abb abbb …</p><p>8.匹配重复<br>元字符：？<br>匹配规则：匹配前面的正则表达式重复0次或1次<br>ab？ —&gt;a,ab</p><p>9.匹配重复<br>元字符：{n}<br>匹配规则：匹配指定的重复次数<br>ab{3}—&gt;abbb</p><p>10.匹配重复<br>元字符：{m,n}<br>匹配规则：匹配前面的正则表达式m次到n次<br>ab{3,5}—&gt; abbb,abbbb,abbbbb</p><p>11.匹配字符集合<br>元字符：[]<br>匹配规则：匹配中括号内的任意一个字符<br>[abcd1] a b c d 1<br>[a-z]<br>[A-Z]<br>[0-9]<br>[123a-zA-Z]</p><p>12.匹配字符集合<br>元字符：[^…]<br>匹配规则：匹配除指定字符集之外的任意字符</p><p>13.匹配任意(非)数字字符<br>元字符：\d \D<br>匹配规则：\d 匹配任意数字字符 [0-9]<br>          \D 匹配任意非数字字符 [^0-9]</p><p>14.匹配（非）普通字符（普通字符：数字，字母，下划线）<br>元字符：\w   \W<br>匹配规则：\w 匹配任意一个普通字符 [_0-9a-zA-Z]<br>          \W 匹配任意一个非普通字符 [^_0-9a-zA-Z]</p><p>15.匹配（非）空字符<br>元字符：\s    \S<br>匹配规则：\s 匹配任意一个空字符<br>          \S 匹配任意一个非空字符<br>空字符：[ \n\t\r]</p><p>16.匹配起止位置<br>元字符： \A   \Z<br>匹配规则：\A 匹配开始位置  ^<br>          \Z 匹配结束位置  $<br>绝对匹配 \Aabc\Z  —&gt; abc 只能是abc</p><p>17.匹配(非)单词边界位置<br>元字符：\b     \B<br>匹配规则：\b 匹配单词边界<br>          \B 匹配非单词边界</p><p>单词边界：数字字母下划线和其他字符的交界位置为单词的边界</p><p>元字符总结：<br>匹配单个字符：a . \d \D \w \W \s \S [] [^…]<br>匹配重复性：* + ？ {N} {m,n}<br>匹配某个位置：^ $ \A \Z \b \B<br>其他：| () \</p><p>re.findall(‘^\d[0-9a-zA-Z]{7,9}’,’1caijie2b’)</p><p>正则表达式特殊符号<br>. * ？ $ ‘’ “” [] {}() \ ^<br>如果想匹配特殊符号则加转义</p><p>贪婪和非贪婪</p><p>正则表达式默认的重复匹配模式：贪婪模式<br>尽可能多的向后匹配</p><ul><li><ul><li>？ {m,n} 这四种情况下会产生贪婪模式<br>非贪婪模式：尽可能少的匹配内容，满足正则表达式含义即可</li></ul></li></ul><p>贪婪—&gt;非贪婪 *？ +？ ？？ {m,n}？</p><p>正则表达式分组<br>使用（）可以为一个正则表达式建立一个子组，子组可以看做内部的整体</p><p>abcd(ef)—&gt; abcdef</p><p>子组的作用<br>1.增加子组后对正则表达式整体的匹配内容没有影响<br>2.子组可以改变重复元字符的重复行为<br>3.子组在某些操作中可以对子组匹配内容单独提取<br>子组的注意事项<br>1.每个正则表达式可以有多个子组，由外到内，由左到右为第一，第二…子组<br>2.子组通常不要交叉</p><p>捕获组和非捕获组（命名组和非命名组）<br>子组命名格式<br>（？P<name>abc）<br>很多编程接口可以直接通过名字获取子组匹配内容<br>捕获组中的正则表达式可以通过名字重复调用</name></p><p>调用：（？P=name）<br>(?P<aa>ab)cdef(?P=aa)—&gt;abcdefab</aa></p><p>re模块</p><p>compile(pattern,flags=0)<br>功能：获取正则表达式对象<br>参数：pattern：正则表达式<br>      falgs：功能标志位，提供更丰富的匹配<br>返回值：正则表达式对象</p><p>re模块和compile对象均有的函数</p><p>obj.findall(string,pos,endpos)<br>功能：通过正则表达式匹配字符串<br>参数：string 目标字符串<br>      pos    目标字符串的匹配开始位置<br>      posend 目标字符串的匹配结束位置<br>返回值：匹配到的所有内容以列表返回<br>如果正则表达式有子组的话则只显示子组匹配内容</p><p>obj.split(string)<br>功能：按照正则表达式切割字符串<br>参数：目标字符串<br>返回值：切割后的内容，以列表的形式返回</p><p>obj.sub(replaceStr，string，count)<br>功能：替换正则表达式匹配的内容<br>参数：replaceStr    要替换的内容<br>      string        目标字符串<br>      count        最多替换几处<br>返回值：返回替换后的字符串</p><p>obj.subn(repl,string,count)<br>功能：替换正则表达式匹配的内容<br>参数：replaceStr    要替换的内容<br>      string        目标字符串<br>      count        最多替换几处<br>返回值：返回替换后的字符串和实际替换的个数</p><p>obj.finditer()<br>功能：使用正则表达式匹配目标内容<br>参数：目标字符串<br>返回值：迭代对象，迭代的每个对象为一个match对象</p><p>re.match(pattern,string)<br>功能：匹配一个字符串的开头<br>参数：目标字符串<br>返回值：迭代对象，迭代的每个对象为一个match对象<br>    没有匹配返回None</p><p>re.search(pattern,string)<br>功能：匹配一个字符串<br>参数：目标字符串<br>返回值：如果匹配返回match obj<br>        没有匹配返回None</p><p>match 只能匹配字符串的开头，search可以匹配任意字符位置，但是也只能匹配一次<br>match对象调用其他属性时往往需要try异常处理</p><p>re.fullmatch()<br>要求目标字符串完全匹配</p><p>compile对象属性方法（re模块没有）</p><p>flags：标志位<br>pattern：正则表达式<br>groupindex：捕获组<br>groups：多少个子组</p><p>match对象属性方法</p><p>pos:目标字符串的开头位置<br>endpos：目标字符串的结束位置<br>re:正则表达式对象<br>lastgroup:最后一组的名字<br>lastindex: 最后一组是第几组<br>string:目标字符串</p><p>start():匹配到内容的开始位置<br>end(): 匹配到内容的结束位置<br>span():匹配到内容的起止位置</p><p>group(n):<br>功能：获取match对象匹配的内容<br>参数：默认为0，表示获取正则整体的匹配内容<br>      如果传入大于0的整数则表示获取对应子组匹配内容<br>返回值：返回匹配到的内容</p><p>groups():<br>功能：得到所有子组匹配的内容</p><p>groupdict():<br>功能：得到所有捕获组匹配的内容</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正则表达式&lt;/p&gt;
&lt;p&gt;动机&lt;br&gt;1.处理文本成为计算机常见工作之一&lt;br&gt;2.对文本内容的搜索提取是一项比较复杂困难的工作&lt;br&gt;3.为了快速方便处理上述问题，正则表达式技术诞生，逐渐被发展为一个被众多语言使用的独立技术&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="re" scheme="https://CzsGit.github.io/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>进程间通信方式</title>
    <link href="https://CzsGit.github.io//blog/2018/04/13/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/13/进程间通信方式.html</id>
    <published>2018-04-13T12:24:27.000Z</published>
    <updated>2022-07-14T01:58:42.807Z</updated>
    
    <content type="html"><![CDATA[<p>进程间通信</p><p>磁盘交互：1.速度慢<br>          2.不安全</p><p>socket 本地套接字</p><p>管道 消息队列 共享内存 信号 信号量 套接字</p><p>管道通信<br><a id="more"></a><br>在内存中开辟一块空间，对多个进程可见，通过管道，多进程进行通信</p><p>multiprocessing–&gt;pipe</p><p>fd1,fd2=Pipe(duplex=True)<br>功能：创建一个管道<br>参数：duplex 默认为True 表示是个双向管道<br>      设置为False则表示单向管道<br>返回值：返回两个管道流对象，表示管道的两端<br>        如果是双向管道则两个均可读写<br>        如果是单向管道则fd1只能读，fd2只能写</p><p>接收消息，fd1.recv（）<br>功能：接收消息（每次一条）<br>参数：无<br>返回值：接收到的消息<br>如果管道没有消息会阻塞</p><p>发送消息，fd2.send（）<br>功能：发送消息，可以是字符串或其他类型<br>参数：要发送的内容<br>如果没有接收端管道破裂</p><p>消息队列<br>队列：先进先出</p><p>在内存中开辟队列模型，用来存放消息，任何拥有队列的进程都可以存取消息</p><p>队列的创建</p><pre><code>multiprocessing QueueQueue（maxsize=0）功能：创建一个消息队列      在Python中有标准模块queue，队列模型，和进程无关参数：maxsize默认为0 表示队列可存放消息由内存而定      &gt;0 表示队列最多存放多少条消息q.put（）功能：向队列中存放消息参数：要存的消息（字符串，整数，队列）      当队列满时会阻塞      q.full()判断队列是否为满，如果满返回Trueq.get()功能：向队列中取出消息返回值：取出的消息当队列为空时会阻塞q.empty()判断队列是否为空，空返回Trueq.qsize()得到当前队列中消息的个数q.close()关闭队列put get 中均有可选参数block和timeoutblock默认为True表示阻塞函数，如果设置为False则不阻塞timeout block为True时设置超时时间</code></pre><p>共享内存（效率高）<br>    在内存中开辟一段空间，存储数据，对多个进程可见<br>    每次写入共享内存的数据会覆盖之前的内容<br>    由于对内存格式化较少，所以存取速度快</p><pre><code>from multiprocessing import Value,Arrayobj=Value(ctype,obj)功能：开辟共享内存空间参数：ctype str 要转变的c类型（对照ctype表）      obj 写入共享内存的初始值返回值：返回一个共享内存对象obj.value 即可得到共享内存中的值obj=Array(ctype,obj)功能：开辟共享内存空间参数：ctype 要转换的类型      obj   存入到共享内存中的数据            是一个列表，要求列表中数据类型一致            是一个整数，表示开辟一个多大的空间返回一个共享内存对象</code></pre><p>信号<br>    一个进程向另一个进程通过信号传递某种信息</p><p>kill -l 查看信号<br>kill -signame PID  给PID发送一个信号</p><p>关于信号：</p><p>信号名称：系统定义，信号的名字<br>信号的含义：系统定义，信号的作用<br>信号的默认处理方法：系统定义，信号给接收进程带来的行为，一般有终止，暂停，忽略</p><p>Python如何操作信号</p><pre><code>发送    os.kill(pid,sig)    功能：向一个进程发送一个信号    参数：pid:要发送信号的进程pid号          sig:要发送的信号    signal.alarm(sec)    功能：向自身发送一个时钟信号 SIGALRM    参数：sec时钟秒数    信号属于异步通讯方式，信号的发送不会影响进程的持续执行    一个进程中只能同时有一个时钟，后面的时钟时间会覆盖前面的处理：    signal.pause()    功能：阻塞等待一个信号的发生    signal.signal(signum,handler)    功能：处理一个信号    参数：signum：要处理的信号          handler：对该信号的处理方法                    SIG_DFL：采取原信号的默认方法处理                    SIG_IGN：忽略接收到的信号                    func：     回调函数，自定义的方法处理    signal函数是一个异步处理信号函数，只要执行，在进程中就会按照指定方法处理信号    signal不能处理SIGSTOP，SIGKILL信号    func格式要求：        def func（sig，frame）：            ...    sig:接收到的信号    frame：信号对象，可以操作信号的属性</code></pre><p>信号量：给定一定的信号量，对多个进程可见，并且多个进程均可操作，进程根据信号量<br>        的多少，可以有不同的行为</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程间通信&lt;/p&gt;
&lt;p&gt;磁盘交互：1.速度慢&lt;br&gt;          2.不安全&lt;/p&gt;
&lt;p&gt;socket 本地套接字&lt;/p&gt;
&lt;p&gt;管道 消息队列 共享内存 信号 信号量 套接字&lt;/p&gt;
&lt;p&gt;管道通信&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="process" scheme="https://CzsGit.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>进程池</title>
    <link href="https://CzsGit.github.io//blog/2018/04/12/%E8%BF%9B%E7%A8%8B%E6%B1%A0.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/12/进程池.html</id>
    <published>2018-04-12T07:20:25.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>进程池<br>在需要频繁的创建删除较多进程的情况下，导致计算机资源消耗过多</p><p>进程池如何处理</p><p>1.创建进程池，在池内放入适量的进程<br>2.将事件加入进程池等待队列<br>3.使用进程池中的进程不断处理事件<br>4.所有事件处理后，回收关闭进程池<br><a id="more"></a><br>from multiprocessing import Pool</p><p>Pool（）<br>功能：创建进程池<br>参数：precesses：指定进程池中进程数量<br>返回值：得到进程池对象</p><p>pool.apply_async()<br>功能：异步方式将事件放入进程池执行<br>参数： func：要执行的事件函数<br>       args：同Process args<br>       kwds：同Process kwargs<br>返回值：返回一个对象，该对象可以通过get()方法得到func函数的返回值<br>pool.close（）<br>功能：关闭进程池，使其无法加入新事件<br>pool.join()<br>功能：阻塞等待进程池退出（当所有事件处理完毕后）</p><p>pool.apply()<br>用法和apply_async一样，只是需要顺序执行，一个<br>事件结束后再执行另一个事件</p><p>pool.map(func，iter)<br>功能：类似于内建函数map，将第二个参数的迭代数传递给第一个参数的函数执行。同时兼容了使用进程池执行<br>返回值：返回func的返回值列表<br>r=pool.map(func,test)–&gt;<br>                        r=[]<br>                        for i in test:<br>                            res=pool.apply_async(fun,(i,))<br>                            r.append(res.get())</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进程池&lt;br&gt;在需要频繁的创建删除较多进程的情况下，导致计算机资源消耗过多&lt;/p&gt;
&lt;p&gt;进程池如何处理&lt;/p&gt;
&lt;p&gt;1.创建进程池，在池内放入适量的进程&lt;br&gt;2.将事件加入进程池等待队列&lt;br&gt;3.使用进程池中的进程不断处理事件&lt;br&gt;4.所有事件处理后，回收关闭进程池&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="process" scheme="https://CzsGit.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>multiprocessing模块</title>
    <link href="https://CzsGit.github.io//blog/2018/04/09/multiprocessing%E6%A8%A1%E5%9D%97.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/09/multiprocessing模块.html</id>
    <published>2018-04-09T12:09:41.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>multiprocessing<br>模块创建进程，标准库<br>1.需要将事件封装为函数<br>2.使用multiprocessing提供的类创建新进程<br>3.新的进程和对应的函数相关联，进程启动会自动执行函数，完成事件<br>4.进程回收<br><a id="more"></a><br>创建子进程类</p><p>multiprocessing.Process()<br>功能：创建子进程<br>参数：name:给创建的进程起一个名字 默认process-1<br>      target：目标函数<br>      args：元组，要给函数传递的参数 位置<br>      kwargs：字典，要给函数传递的参数 键值</p><p>进程对象属性函数<br>p.start()<br>功能：启动子进程 此时进程真正创建</p><p>p.join([timeout])<br>功能：阻塞等待回收相应的子进程<br>参数：默认为阻塞，timeout为超时时间</p><p>p的其他属性<br>p.name 进程名称<br>p.pid 创建的进程的pid号<br>p.is_alive（） Ture：进程处于活跃状态，False：进程处于终止状态</p><p>p.daemon 默认值为False表示主进程结束后不影响子进程的执行<br>         如果设置为True则主进程执行完毕所有的子进程一同<br>         退出</p><pre><code>*设置必须在start（）前*一般使用daemon=True时，不用加join*该属性并不是linux/unix系统中所说得守护进程设置守护进程：生命周期长，随系统创建，随系统销毁          不受前端控制，后台运行          操作系统进程，或者是自动化运行进程居多</code></pre><p>获取文件的大小<br>size=os.path.getsize(‘file’)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;multiprocessing&lt;br&gt;模块创建进程，标准库&lt;br&gt;1.需要将事件封装为函数&lt;br&gt;2.使用multiprocessing提供的类创建新进程&lt;br&gt;3.新的进程和对应的函数相关联，进程启动会自动执行函数，完成事件&lt;br&gt;4.进程回收&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>僵尸进程</title>
    <link href="https://CzsGit.github.io//blog/2018/04/03/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/03/僵尸进程.html</id>
    <published>2018-04-03T12:07:49.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>孤儿进程：<br>    父进程先于子进程退出，此时子进程便为孤儿进程<br>    孤儿进程会被系统指定的进程所“收养”，即该进程称为孤儿进程的新的父进程<br>    在孤儿进程退出时，“继父”会进行处理，不会是其成为僵尸进程<br><a id="more"></a><br>僵尸进程：</p><pre><code>子进程先于父进程退出，但是父进程没有处理子进程的退出状况，子进程就会变成僵尸进程。僵尸进程会滞留PCB的部分信息在内存中大量的僵尸进程会消耗系统资源，所以应该尽量避免僵尸进程的产生</code></pre><p>如何避免僵尸进程的产生<br>    1.让父进程先退出（不好控制）<br>    2.让父进程处理子进程的退出</p><pre><code>    使用wait或者waitpid函数    os.wait()    功能：等待子进程的退出，进行处理    参数：无    返回值：一个元组，第一个值为退出的子进程pid                      第二个值为子进程退出状态    使用信号处理    os.waitpid(pid,option)    功能：处理子进程的退出    参数 pid：-1 表示等待任意的子进程退出              &gt;0 表示等待相应的pid号的子进程         option：0 表示阻塞等待                 WNOHANG： 表示非阻塞等待,需要循环处理查看子进程的状态    返回值：同wait3.创建二级子进程    父进程创建子进程后，等待子进程退出    子进程创建二级子进程后，马上退出，二级子进程成为孤儿进程    让父进程和二级子进程处理具体事件</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;孤儿进程：&lt;br&gt;    父进程先于子进程退出，此时子进程便为孤儿进程&lt;br&gt;    孤儿进程会被系统指定的进程所“收养”，即该进程称为孤儿进程的新的父进程&lt;br&gt;    在孤儿进程退出时，“继父”会进行处理，不会是其成为僵尸进程&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="process" scheme="https://CzsGit.github.io/tags/process/"/>
    
  </entry>
  
  <entry>
    <title>TCP粘包处理方法</title>
    <link href="https://CzsGit.github.io//blog/2018/04/02/TCP%E7%B2%98%E5%8C%85%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95.html"/>
    <id>https://CzsGit.github.io//blog/2018/04/02/TCP粘包处理方法.html</id>
    <published>2018-04-02T06:17:59.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tcp粘包处理"><a href="#tcp粘包处理" class="headerlink" title="tcp粘包处理"></a>tcp粘包处理</h3><p>tcp中数据以数据流的方式发送接收，每次发送的数据间没有边界，在接收时可能造成数据的粘连即为粘包</p><p>粘包如何处理：<br>    1.每次发送消息结束位置加标志<br>    2.发送的消息添加结构描述<br>    3.当连续发送时每次发送有一个短暂的延迟 sleep(0.1)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;tcp粘包处理&quot;&gt;&lt;a href=&quot;#tcp粘包处理&quot; class=&quot;headerlink&quot; title=&quot;tcp粘包处理&quot;&gt;&lt;/a&gt;tcp粘包处理&lt;/h3&gt;&lt;p&gt;tcp中数据以数据流的方式发送接收，每次发送的数据间没有边界，在接收时可能造成数据的粘连即为粘包&lt;/
      
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
      <category term="socket" scheme="https://CzsGit.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>fork多进程</title>
    <link href="https://CzsGit.github.io//blog/2018/03/26/fork%E5%A4%9A%E8%BF%9B%E7%A8%8B.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/26/fork多进程.html</id>
    <published>2018-03-26T11:56:33.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<h5 id="使用fork方法，创建多进程"><a href="#使用fork方法，创建多进程" class="headerlink" title="使用fork方法，创建多进程"></a>使用fork方法，创建多进程</h5><p>import os</p><p>os.fork()<br>功能：创建一个新的进程<br>参数：无<br>返回值：失败返回一个负数， -1<br>        成功 0 在子进程中fork的返回值</p><pre><code>&gt;0的正整数（新进程的PID号）在父进程中的返回值</code></pre><a id="more"></a><p>父进程中fork之前的内容子进程同样会复制，但父子进程空间独立，fork之后的修改不会影响到对方<br>父子进程在执行上互不影响，谁先执行，谁先执行完不确定<br>子进程虽然复制父进程的空间，但是有自己的特性，比如自己的PID，进程PCB,进程栈空间等。</p><h5 id="进程相关函数"><a href="#进程相关函数" class="headerlink" title="进程相关函数"></a>进程相关函数</h5><p>获取PID号<br>os.getpid()<br>功能：获取当前进程的PID号<br>返回值：当前进程PID</p><p>os.getppid()<br>功能：获取当前进程父进程的PID号<br>返回值：父进程PID</p><p>进程的退出</p><p>os._exit(status)</p><p>功能：结束一个进程<br>参数：表示进程的结束状态，是一个整数<br>0：表示程序正常退出<br>1：异常退出<br>sys.exit([status])<br>功能：结束一个进程，抛出异常<br>参数：传入一个正整数，表示结束状态<br>      传入字符串，表示结束打印</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;使用fork方法，创建多进程&quot;&gt;&lt;a href=&quot;#使用fork方法，创建多进程&quot; class=&quot;headerlink&quot; title=&quot;使用fork方法，创建多进程&quot;&gt;&lt;/a&gt;使用fork方法，创建多进程&lt;/h5&gt;&lt;p&gt;import os&lt;/p&gt;
&lt;p&gt;os.fork()&lt;br&gt;功能：创建一个新的进程&lt;br&gt;参数：无&lt;br&gt;返回值：失败返回一个负数， -1&lt;br&gt;        成功 0 在子进程中fork的返回值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt;0的正整数（新进程的PID号）在父进程中的返回值
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>IO多路复用</title>
    <link href="https://CzsGit.github.io//blog/2018/03/25/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/25/IO多路复用.html</id>
    <published>2018-03-25T11:34:09.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h5><p>同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件，形成并发的效果</p><h5 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h5><p>并发：多个事件同时发生，产生一个同时处理的效果<br>并行：多个事件同时进行<br><a id="more"></a></p><h5 id="多路复用之select模块"><a href="#多路复用之select模块" class="headerlink" title="多路复用之select模块"></a>多路复用之select模块</h5><p>import select</p><p>select —&gt; win,linux,uinx<br>poll —&gt; linux,uinx<br>epoll —&gt;linux,uinx</p><p>r,w,x=select(rlist,wlist,xlist,[timeout])<br>功能：监控IO事件，阻塞等待IO事件发生<br>参数：rlist: 列表 存放我们要监控等待处理的IO<br>             需要满足一定的条件才能够发生的事<br>             存储在这个列表中<br>      wlist：列表 存放我们希望主动处理的IO<br>             wlist中的内容会立即返回，处理<br>             比如send发送，可以自主处理<br>             不经常使用，容易被忽略<br>      xlist：列表 存放如果发生异常需要我们处理的<br>             监控异常发生的列表<br>      timeout：数字 表示超时检测 默认一直阻塞<br>               超过这个时间后结束阻塞</p><p>当任意一个事件准备就绪后，返回<br>返回值：r:列表 rlist当中准备就绪的IO<br>        w:列表 wlist中准备就绪的IO<br>        x:列表 xlist中准备就绪的IO</p><h5 id="IO多路复用注意点："><a href="#IO多路复用注意点：" class="headerlink" title="IO多路复用注意点："></a>IO多路复用注意点：</h5><pre><code>1.在处理IO过程中不应该发生死循环（某个IO单独占有服务器）2.IO多路复用是单进程程序，是一个并发程序3.IO多路复用有较高的IO执行效率</code></pre><h5 id="多路复用之poll模块"><a href="#多路复用之poll模块" class="headerlink" title="多路复用之poll模块"></a>多路复用之poll模块</h5><pre><code>1.创建poll对象p=select.poll()    2.加入关注的IOp.register(s)p.unregister(s) 从关注IO中删除3.使用poll函数监控events=p.poll()功能：阻塞函数，直到任意一个监控的对象准备就绪返回值：event[(fileno,event),(),()]fileno:准备就绪事件的filenoevent：用来判断一个事件是否准备就绪4.处理发生的IO事件poll io事件POLLIN POLLOUT POLLUP    POLLERR  POLLPRI    POLLVALrlist    wlist  断开连接  xlist    紧急处理   无效数据</code></pre><h5 id="多路复用之epoll模块"><a href="#多路复用之epoll模块" class="headerlink" title="多路复用之epoll模块"></a>多路复用之epoll模块</h5><p>效率上比poll和select稍微高点<br>    内核找到就绪io后直接返回，不用在应用层遍历一遍<br>只能用于linux，unix<br>支持边缘触发<br>    select poll只支持水平触发<br>    水平触发：<br>        每隔一段时间都访问一次应用层，通知事件就绪，不阻塞<br>    边缘触发：<br>        一次没有处理后继续阻塞，当有新的事件就绪后，一起返回</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;什么是IO多路复用&quot;&gt;&lt;a href=&quot;#什么是IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;什么是IO多路复用&quot;&gt;&lt;/a&gt;什么是IO多路复用&lt;/h5&gt;&lt;p&gt;同时监控多个IO事件，当哪个IO事件准备就绪就执行哪个IO事件，形成并发的效果&lt;/p&gt;
&lt;h5 id=&quot;并发和并行的区别&quot;&gt;&lt;a href=&quot;#并发和并行的区别&quot; class=&quot;headerlink&quot; title=&quot;并发和并行的区别&quot;&gt;&lt;/a&gt;并发和并行的区别&lt;/h5&gt;&lt;p&gt;并发：多个事件同时发生，产生一个同时处理的效果&lt;br&gt;并行：多个事件同时进行&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>TCP应用之HTTP传输</title>
    <link href="https://CzsGit.github.io//blog/2018/03/23/TCP%E5%BA%94%E7%94%A8%E4%B9%8BHTTP%E4%BC%A0%E8%BE%93.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/23/TCP应用之HTTP传输.html</id>
    <published>2018-03-23T11:25:52.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<h5 id="TCP应用之http传输"><a href="#TCP应用之http传输" class="headerlink" title="TCP应用之http传输"></a>TCP应用之http传输</h5><p>通途：网站中网页的传输和数据传输<br>      也可用作基于http协议的编程传输数据<br><a id="more"></a><br>特点：应用层协议，传输层是用tcp连接<br>      简单，灵活，接口使用方便<br>      几乎支持所有的数据类型<br>      是无状态的协议（通信过程中不记录客户端的访问状态）<br>      比如登录京东，登录一个网页后再打开另一个网页不许登录，这种状态的记录不是由http协议规定的<br>      是由浏览器私自规定的cookies记录的，为了方便访问记录的用户状态，http协议本身不会做任何的记录<br>      持续连接<br>      http1.1版本 做的修改<br>      在http1.0之前是无连接，每次访问后断开，之后从新连接<br>      之后做的修改后为持续连接<br>      详见：《http图解》</p><h5 id="请求（request）"><a href="#请求（request）" class="headerlink" title="请求（request）"></a>请求（request）</h5><p>格式：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">请求行：确定具体的请求类型</span><br><span class="line">请求头：对请求内容的信息描述</span><br><span class="line">空行</span><br><span class="line">请求正文：具体请求参数</span><br><span class="line"></span><br><span class="line">请求行：GTE       /index.html    HTTP/1.1</span><br><span class="line">请求方法   请求资源      协议版本</span><br><span class="line">请求方法：GET：获取网络资源</span><br><span class="line">  POST：提交一定的附加数据得到返回结果</span><br><span class="line">  HEAD：只获取响应的头信息</span><br><span class="line">  PUT：获取服务器的资源</span><br><span class="line">  <span class="keyword">DELETE</span>：删除服务器资源</span><br><span class="line">  <span class="keyword">TRACE</span>：用于测试</span><br><span class="line">  <span class="keyword">CONNECT</span>：保留方法</span><br><span class="line">  OPTIONS：请求获取服务器性能和信息</span><br><span class="line"></span><br><span class="line">请求体：</span><br><span class="line"><span class="keyword">get</span>请求<span class="comment">---》get参数  &amp;a=1&amp;b=2</span></span><br><span class="line">post请求<span class="comment">---》post提交的内容</span></span><br></pre></td></tr></table></figure></p><h5 id="响应（response）"><a href="#响应（response）" class="headerlink" title="响应（response）"></a>响应（response）</h5><p>格式：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">响应行：反馈响应的情况</span><br><span class="line">响应头：对响应的具体描述</span><br><span class="line">空行</span><br><span class="line">响应体：具体返回给用户的内容</span><br><span class="line"></span><br><span class="line">响应行： HTTP/<span class="number">1.1</span> <span class="number">200</span>    OK</span><br><span class="line">协议版本 响应码 信息</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>xx：提示信息，表示请求已经接受，正在处理</span><br><span class="line"><span class="number">2</span>xx：请求响应成功</span><br><span class="line"><span class="number">3</span>xx：重定向，完成任务需要其他操作</span><br><span class="line"><span class="number">4</span>xx：请求资源不存在，客户端错误</span><br><span class="line"><span class="number">5</span>xx：服务端错误</span><br><span class="line"></span><br><span class="line"><span class="number">200</span>：成功</span><br><span class="line"><span class="number">401</span>：没有访问权限</span><br><span class="line"><span class="number">404</span>：资源不存在</span><br><span class="line"><span class="number">500</span>：服务器发生未知错误</span><br><span class="line"><span class="number">503</span>：服务器暂时无法执行</span><br><span class="line"></span><br><span class="line">响应头格式同请求头</span><br><span class="line">响应体：具体内容</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;TCP应用之http传输&quot;&gt;&lt;a href=&quot;#TCP应用之http传输&quot; class=&quot;headerlink&quot; title=&quot;TCP应用之http传输&quot;&gt;&lt;/a&gt;TCP应用之http传输&lt;/h5&gt;&lt;p&gt;通途：网站中网页的传输和数据传输&lt;br&gt;      也可用作基于http协议的编程传输数据&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="tcp" scheme="https://CzsGit.github.io/categories/tcp/"/>
    
    
      <category term="tcp" scheme="https://CzsGit.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>搭建简单TCP连接</title>
    <link href="https://CzsGit.github.io//blog/2018/03/23/%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95TCP%E8%BF%9E%E6%8E%A5.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/23/搭建简单TCP连接.html</id>
    <published>2018-03-23T11:08:58.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>TCP服务端</p><p>from socket import *<br>１．创建套接字<br>socket(socket_family=AF_INET,<br>       socket_type=SOCK_STREAM,<br>       proto=0)<br><a id="more"></a><br>功能：创建套接字<br>参数：socket_family: 选择地址簇种类　AF_INET<br>     socket_type: 套接字类型SOCK_STREAM 流式套接字<br>                          SOCK_DGRAM 数据报套接字<br>    　proto: 子协议类型默认为０<br>返回值：返回创建的套接字<br>２．绑定IP和端口号</p><p>sockfd.bind()<br>功能：　绑定IP和端口<br>参数：　是一个元组，第一项是字符串形式的IP<br>               第二项是端口号<br>    （’192,168,1,1’,8888)</p><p>３．让套接字具有监听功能<br>sockfd.listen(n)<br>功能：使套接字变为监听套接字，同时创建监听队列<br>参数：n监听队列大小</p><p>４．等待客户端连接<br>sockfd.accept()<br>功能：阻塞等待客户端连接<br>返回值：第一个：返回一个新的套接字用来和客户端同信<br>    　　第二个：返回连接的客户端的地址</p><p>５．消息的收发<br>recv(buffer)<br>功能：接受消息<br>参数：一次接受消息的大小　字节<br>返回值：返回接收到的内容</p><p>send(data)<br>功能：发送消息<br>参数：发送的内容（发送byte格式的字节）<br>返回值：发送了多少个字节<br>当没有接收端的时候send操作会导致　broken pipe<br>６．关闭套接字<br>close()<br>功能：关闭套接字</p><p>TCP客户端</p><p>１．创建流式套接字<br>２．发起连接请求<br>connect()<br>功能：发起连接<br>参数：一个元组　第一个元素：　服务器的IP<br>            第二个元素： 服务器的port</p><p>３．收发消息<br>４．关闭套接字</p><p>tcp_client.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建套接字</span></span><br><span class="line">sockfd=socket(AF_INET,SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#发起连接</span></span><br><span class="line">sockfd.connect((<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment">#发送消息</span></span><br><span class="line">    msg=input(<span class="string">'input：'</span>)</span><br><span class="line">    sockfd.send(msg.encode())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#接受消息</span></span><br><span class="line">    data=sockfd.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭连接</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure></p><p>tcp_server.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#创建流式套接字</span></span><br><span class="line">sockfd=socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绑定IP和端口</span></span><br><span class="line">sockfd.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8882</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为监听套接字，创建监听队列</span></span><br><span class="line">sockfd.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="comment">#等待客户端连接</span></span><br><span class="line">    print(<span class="string">'waiting for connect...'</span>)</span><br><span class="line">    input(<span class="string">'hello'</span>)</span><br><span class="line">    connfd,addr=sockfd.accept()</span><br><span class="line">    print(<span class="string">'connect from:'</span>,addr)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment">#收发消息</span></span><br><span class="line">        data=connfd.recv(<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(data.decode())</span><br><span class="line">        connfd.send(<span class="string">'receive your message'</span>.encode())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#关闭套接字</span></span><br><span class="line">    connfd.close()</span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TCP服务端&lt;/p&gt;
&lt;p&gt;from socket import *&lt;br&gt;１．创建套接字&lt;br&gt;socket(socket_family=AF_INET,&lt;br&gt;       socket_type=SOCK_STREAM,&lt;br&gt;       proto=0)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
      <category term="tcp" scheme="https://CzsGit.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>浅析udp</title>
    <link href="https://CzsGit.github.io//blog/2018/03/22/%E6%B5%85%E6%9E%90udp.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/22/浅析udp.html</id>
    <published>2018-03-22T12:02:42.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>udp通信</p><h5 id="1-创建套接字"><a href="#1-创建套接字" class="headerlink" title="1.创建套接字"></a>1.创建套接字</h5><pre><code>sockfd=socket(AF_INET,SOCK_DGRAM)</code></pre><h5 id="2-绑定服务端地址"><a href="#2-绑定服务端地址" class="headerlink" title="2.绑定服务端地址"></a>2.绑定服务端地址</h5><pre><code>ADDR=(&apos;192.188.1.2&apos;,8888)sockfd.bind(ADDR)</code></pre><a id="more"></a><h5 id="3-收发消息"><a href="#3-收发消息" class="headerlink" title="3.收发消息"></a>3.收发消息</h5><pre><code>data,addr=recvfrom(buffersize)功能：接收数据报套接字消息参数：每次最多接收消息的大小 单位：字节返回值：data 接收到的消息，addr 消息发送者的地址一次接收一个数据包，如果数据包一次没有接收完则会丢失没接收的内容sendto(data,addr)功能：发送消息参数：data 要发送的消息      addr 发送给某个主机的地址返回值：发送消息的字节数</code></pre><h5 id="4-关闭套接字"><a href="#4-关闭套接字" class="headerlink" title="4.关闭套接字"></a>4.关闭套接字</h5><pre><code>close()</code></pre><p>udp_client.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment">#从命令行传入ip和端口</span></span><br><span class="line"><span class="comment">#python3 udp_server.py 127.0.0.1 8888</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv)&lt;<span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'''</span></span><br><span class="line"><span class="string">            argv is error</span></span><br><span class="line"><span class="string">            input as</span></span><br><span class="line"><span class="string">            python3 udp_server.py 127.0.0.1 8888</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">host = sys.argv[<span class="number">1</span>]</span><br><span class="line">port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">addr = (host,port)</span><br><span class="line">buffersize=<span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据报套接字</span></span><br><span class="line">sockfd=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data = input(<span class="string">'消息&gt;&gt;'</span>)</span><br><span class="line">    <span class="comment">#回车退出</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sockfd.sendto(data.encode(),addr)</span><br><span class="line">    data,addr=sockfd.recvfrom(buffersize)</span><br><span class="line">    print(<span class="string">'从服务器接收到：'</span>,data.decode())</span><br><span class="line"></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure></p><p>udp_server.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> ctime</span><br><span class="line"></span><br><span class="line"><span class="comment">#从命令行传入ip和端口</span></span><br><span class="line"><span class="comment">#python3 udp_server.py 127.0.0.1 8888</span></span><br><span class="line"><span class="keyword">if</span> len(sys.argv)&lt;<span class="number">3</span>:</span><br><span class="line">    print(<span class="string">'''</span></span><br><span class="line"><span class="string">            argv is error</span></span><br><span class="line"><span class="string">            input as</span></span><br><span class="line"><span class="string">            python3 udp_server.py 127.0.0.1 8888</span></span><br><span class="line"><span class="string">            '''</span>)</span><br><span class="line">host = sys.argv[<span class="number">1</span>]</span><br><span class="line">port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">addr = (host,port)</span><br><span class="line">buffersize=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据报套接字</span></span><br><span class="line">sockfd=socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment">#绑定地址</span></span><br><span class="line">sockfd.bind(addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#收发消息</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    data,addr=sockfd.recvfrom(buffersize)</span><br><span class="line">    print(<span class="string">'recv from %s:%s'</span>%(addr,data.decode()))</span><br><span class="line">    sockfd.sendto\</span><br><span class="line">    ((<span class="string">'[%s] 接收到消息'</span>%ctime()).encode(),addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;udp通信&lt;/p&gt;
&lt;h5 id=&quot;1-创建套接字&quot;&gt;&lt;a href=&quot;#1-创建套接字&quot; class=&quot;headerlink&quot; title=&quot;1.创建套接字&quot;&gt;&lt;/a&gt;1.创建套接字&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;sockfd=socket(AF_INET,SOCK_DGRAM)
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;2-绑定服务端地址&quot;&gt;&lt;a href=&quot;#2-绑定服务端地址&quot; class=&quot;headerlink&quot; title=&quot;2.绑定服务端地址&quot;&gt;&lt;/a&gt;2.绑定服务端地址&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;ADDR=(&amp;apos;192.188.1.2&amp;apos;,8888)
sockfd.bind(ADDR)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
      <category term="socket" scheme="https://CzsGit.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>__init__()方法和__new__()方法的区别</title>
    <link href="https://CzsGit.github.io//blog/2018/03/21/init-%E6%96%B9%E6%B3%95%E5%92%8C-new-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>https://CzsGit.github.io//blog/2018/03/21/init-方法和-new-方法的区别.html</id>
    <published>2018-03-21T09:54:52.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>下面先通过一段代码看看这两个方法的调用顺序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"init &amp;&amp;&amp;&amp;  %s"</span> % self.__class__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"new &amp;&amp;&amp;&amp;  %s"</span> % cls</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls,*args,**kwargs)</span><br><span class="line"></span><br><span class="line">a=A()</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &amp;&amp;&amp;&amp;  &lt;<span class="keyword">class</span> <span class="comment">'__main__.A'&gt;</span></span><br><span class="line">init &amp;&amp;&amp;&amp;  &lt;<span class="keyword">class</span> <span class="comment">'__main__.A'&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>如果把最后一行的return代码屏蔽掉，输出结果为：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> &amp;&amp;&amp;&amp;&lt;<span class="keyword">class</span> <span class="comment">'__main__.A'&gt;</span></span><br></pre></td></tr></table></figure></p><p>此处为什么会只输出一行，请参考文章[<em>Python中new()方法的使用和实例化]</em>(<a href="http://blog.csdn.net/four_infinite/article/details/52798919" target="_blank" rel="noopener">http://blog.csdn.net/four_infinite/article/details/52798919</a>)</p><p>一般来说，”init”和”new”函数都会有下面的形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># func_suite</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">    <span class="comment"># func_suite</span></span><br></pre></td></tr></table></figure></p><p>对于”new”和”init”可以概括为：<br>“new”方法在Python中是真正的构造方法（创建并返回实例），通过这个方法可以产生一个”cls”对应的实例对象，所以说”new”方法一定要有返回。<br>对于”init”方法，是一个初始化的方法，”self”代表由类产生出来的实例对象，”init”将对这个对象进行相应的初始化操作。</p><p>重写<em>new</em><br>如果（新式）类中没有重写”new”方法，Python默认是调用该类的直接父类的”new”方法来构造该类的实例，如果该类的父类也没有重写”new”，那么将一直按照同样的规则追溯至object的”new”方法，因为object是所有新式类的基类。</p><p>而如果新式类中重写了”new”方法，那么可以选择任意一个其他的新式类（必须是新式类，只有新式类有”new”，因为所有新式类都是从object派生）的”new”方法来创建实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环。</p><p>看一段例子代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = object.__new__(cls,*args,**kwargs)</span><br><span class="line">        <span class="comment">#这里的object.__new__(cls,*args,**kwargs)等价于</span></span><br><span class="line">        <span class="comment"># super(Foo,cls).__new__(cls,*args,**kwargs)</span></span><br><span class="line">        <span class="comment"># object.__new__(Foo,*args,**kwargs)</span></span><br><span class="line">        <span class="comment"># Bar.__new__(cls,*args,**kwargs)</span></span><br><span class="line">        <span class="comment"># Student.__new__(cls,*args,**kwargs),即使Student和</span></span><br><span class="line">        <span class="comment"># Foo没有关系也是允许的，因为Student是由object派生的新类</span></span><br><span class="line">        <span class="comment"># 在任何新式类中，不能调用自身的__new__来创建实例，因为这会</span></span><br><span class="line">        <span class="comment"># 造成死循环，所以要避免出现这样的语法 Foo.__new__(cls,*args,**kwargs)</span></span><br><span class="line">        <span class="comment"># 或者 cls.__new__(cls,*args,**kwargs)</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Calling __new__ for %s"</span> % obj.__class__</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span><span class="params">(Foo)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = object.__new__(cls,*args,**kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Calling __new__ for %s"</span> % obj.__class__</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment">#Student没有__new__方法，那么会自动调用父类的__new__方法来</span></span><br><span class="line">    <span class="comment">#创建实例，即会自动调用object.__new__(cls)</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = object.__new__(Bar,*args,**kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Calling __new__ for %s"</span> % obj.__class__</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">foo = Foo()</span><br><span class="line">bar = Bar()</span><br><span class="line">car = Car()</span><br></pre></td></tr></table></figure></p><p>运行结果是：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Calling <span class="number">__n</span>ew<span class="number">__</span> <span class="keyword">for</span> &lt;<span class="keyword">class</span> <span class="string">'__main__.Foo'</span>&gt;</span><br><span class="line">Calling <span class="number">__n</span>ew<span class="number">__</span> <span class="keyword">for</span> &lt;<span class="keyword">class</span> <span class="string">'__main__.Bar'</span>&gt;</span><br><span class="line">Calling <span class="number">__n</span>ew<span class="number">__</span> <span class="keyword">for</span> &lt;<span class="keyword">class</span> <span class="string">'__main__.Bar'</span>&gt;</span><br></pre></td></tr></table></figure></p><p>_init_的调用</p><p>“new”决定是否要使用该类的”init”方法，因为”new” 可以调用其他类的构造方法或者直接返回别的类创建的对象来作为本类的实例。<br>通常来说，新式类开始实例化时，”new”方法会返回cls（cls指代当前类）的实例，然后调用该类的”init”方法作为初始化方法，该方法接收这个实例（即self）作为自己的第一个参数，然后依次传入”new”方法中接收的位置参数和命名参数。<br>但是，如果”new”没有返回cls（即当前类）的实例，那么当前类的”init”方法是不会被调用的。看下面的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"calling __init__ from %s"</span> % self.__class__</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = object.__new__(cls,*args,**kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"calling __new__ from %s"</span> % obj.__class__</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"calling __init__ from %s"</span> % self.__class__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        obj = object.__new__(A,*args,**kwargs)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"calling __new__ from %s"</span> % obj.__class__</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">b=B()</span><br><span class="line"><span class="keyword">print</span> type(b)</span><br></pre></td></tr></table></figure><p>代码中，在B的”new”方法中，通过”obj = object.new(A, <em>args, *</em>kwargs)”创建了一个A的实例，在这种情况下，B的”init”函数就不会被调用到。<br>运行结果是：<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calling __new__ <span class="keyword">from</span> &lt;<span class="keyword">class</span> <span class="comment">'__main__.A'&gt;</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="comment">'__main__.A'&gt;</span></span><br></pre></td></tr></table></figure></p><p>派生不可变类型<br>关于”new”方法还有一个重要的用途就是用来派生不可变类型<br>例如，python中的float类型是一个不可变类型，如果想要从float中派生出一个子类，就可以使用”new”方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Round2Float</span><span class="params">(float)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,num)</span>:</span></span><br><span class="line">        num = round(num,<span class="number">2</span>)</span><br><span class="line">        obj = float.__new__(Round2Float,num)</span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line">f=Round2Float(<span class="number">4.324599</span>)</span><br><span class="line"><span class="keyword">print</span> f</span><br></pre></td></tr></table></figure></p><p>这段程序从float类中派生出了一个Round2Float类，这个类的作用就是保留小数点后两位的浮点数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面先通过一段代码看看这两个方法的调用顺序：&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#!/usr/bin/env python&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;init &amp;amp;&amp;amp;&amp;amp;&amp;amp;  %s&quot;&lt;/span&gt; % self.__class__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__new__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(cls,*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;new &amp;amp;&amp;amp;&amp;amp;&amp;amp;  %s&quot;&lt;/span&gt; % cls&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; object.__new__(cls,*args,**kwargs)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a=A()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输出结果为：&lt;br&gt;&lt;figure class=&quot;highlight vbnet&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &amp;amp;&amp;amp;&amp;amp;&amp;amp;  &amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;&#39;__main__.A&#39;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;init &amp;amp;&amp;amp;&amp;amp;&amp;amp;  &amp;lt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;&#39;__main__.A&#39;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>2018 Pycharmm 激活方法</title>
    <link href="https://CzsGit.github.io//blog/2018/02/01/2018-Pycharmm-%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95.html"/>
    <id>https://CzsGit.github.io//blog/2018/02/01/2018-Pycharmm-激活方法.html</id>
    <published>2018-02-01T15:06:32.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p> 1、将”0.0.0.0 account.jetbrains.com”添加到hosts文件中<br> 2、打开<a href="http://idea.lanyus.com" target="_blank" rel="noopener">http://idea.lanyus.com</a><br> 3、获取激活码，粘贴到第二个选项中<br> 亲测可用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 1、将”0.0.0.0 account.jetbrains.com”添加到hosts文件中&lt;br&gt; 2、打开&lt;a href=&quot;http://idea.lanyus.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://idea.lanyus
      
    
    </summary>
    
      <category term="tools" scheme="https://CzsGit.github.io/categories/tools/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
      <category term="Pycharm" scheme="https://CzsGit.github.io/tags/Pycharm/"/>
    
  </entry>
  
  <entry>
    <title>python之反射</title>
    <link href="https://CzsGit.github.io//blog/2018/01/08/python%E4%B9%8B%E5%8F%8D%E5%B0%84.html"/>
    <id>https://CzsGit.github.io//blog/2018/01/08/python之反射.html</id>
    <published>2018-01-08T07:51:41.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>什么是反射？<br>１、有时我们要访问某个变量或是方法时并不知道到底有没有这个变量或方法，所以就要做些判断。判断是否存在字符串对应的变量及方法。<br>２、我们知道访问变量时是不能加引号的，否则会被当成字符串处理。如果要通过字符串找到对应的变量，那该怎么办呢<br><a id="more"></a><br>反射就是用于解决上面两个问题而产生的，所谓反射，按我的理解就是反过来告诉我字符串是什么，是变量or方法</p><p>python中访问类或对象的成员有三种方法<br>如下所示　obj 为对象　var为变量 func为函数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">１、obj.<span class="keyword">var</span> 或 obj.<span class="keyword">func</span>()</span><br><span class="line">２、obj.__dict__[<span class="string">'var'</span>]</span><br><span class="line">３、getattr(obj,<span class="string">'var'</span>)</span><br></pre></td></tr></table></figure></p><p>反射有４个方法　getattr() hasattr() setattr() delattr()</p><p>举例子如下，一目了然<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    gvar = <span class="string">'min'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,male)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.male = male</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"func1 :my name is %s"</span> % self.name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"func2 :I'm a %s"</span> % self.male</span><br><span class="line"></span><br><span class="line"><span class="comment">##实例化对象</span></span><br><span class="line">obj = A(<span class="string">'min'</span>,<span class="string">'girl'</span>)</span><br><span class="line">hasattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line">hasattr(obj,<span class="string">'func1'</span>)</span><br><span class="line">getattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line">getattr(obj,<span class="string">'name'</span>)</span><br><span class="line">getattr(obj,<span class="string">'func1'</span>)</span><br><span class="line">getattr(obj,<span class="string">'func2'</span>)()</span><br><span class="line">setattr(obj,<span class="string">'gvar'</span>,<span class="string">'ben'</span>)</span><br><span class="line">getattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line">delattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line"><span class="comment">##python中一切事物都是对象，故其实上面的obj也是可以是类名，模块名</span></span><br><span class="line">getattr(A,<span class="string">'func2'</span>)</span><br><span class="line">hasattr(A,<span class="string">'func1'</span>)</span><br></pre></td></tr></table></figure></p><p>当某个字符串就是模块名时，我们导入模块时可以用以下方法导入<br>mymodule = <strong>import</strong>(var) #这个就相当于导入模块var.py了</p><p>导入后，你可以在你的代码中用mymodule.<code>*</code>来调用该模块下的任意方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>    gvar = <span class="string">'min'</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,male)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line"><span class="meta">... </span>        self.male = male</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"func1 :my name is %s"</span> % self.name</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        <span class="keyword">print</span> <span class="string">"func2 :I'm a %s"</span> % self.male</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">##实例化对象</span></span><br><span class="line"><span class="meta">... </span>obj = A(<span class="string">'min'</span>,<span class="string">'girl'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hasattr(obj,<span class="string">'func1'</span>)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj,<span class="string">'gvar'</span>)</span><br><span class="line"><span class="string">'min'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj,<span class="string">'name'</span>)</span><br><span class="line"><span class="string">'min'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj,<span class="string">'func1'</span>)</span><br><span class="line">&lt;bound method A.func1 of &lt;__main__.A object at <span class="number">0x7f7b89f99a50</span>&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>getattr(obj,<span class="string">'func2'</span>)()</span><br><span class="line">func2 :I<span class="string">'m a girl</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; setattr(obj,'</span>gva<span class="string">r','</span>ben<span class="string">')</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; getattr(obj,'</span>gva<span class="string">r')</span></span><br><span class="line"><span class="string">'</span>ben<span class="string">'</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; delattr(obj,'</span>gva<span class="string">r')</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; ##python中一切事物都是对象，故其实上面的obj也是可以是类名，模块名</span></span><br><span class="line"><span class="string">... getattr(A,'</span>func2<span class="string">')</span></span><br><span class="line"><span class="string">&lt;unbound method A.func2&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; hasattr(A,'</span>func1<span class="string">')</span></span><br><span class="line"><span class="string">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是反射？&lt;br&gt;１、有时我们要访问某个变量或是方法时并不知道到底有没有这个变量或方法，所以就要做些判断。判断是否存在字符串对应的变量及方法。&lt;br&gt;２、我们知道访问变量时是不能加引号的，否则会被当成字符串处理。如果要通过字符串找到对应的变量，那该怎么办呢&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>format函数用法详解</title>
    <link href="https://CzsGit.github.io//blog/2018/01/02/format%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3.html"/>
    <id>https://CzsGit.github.io//blog/2018/01/02/format函数用法详解.html</id>
    <published>2018-01-02T07:10:03.000Z</published>
    <updated>2022-07-14T01:58:42.806Z</updated>
    
    <content type="html"><![CDATA[<p>python之字符串格式化(format)<br>用法：</p><p>　　它通过{}和:来代替传统%方式</p><a id="more"></a><h3 id="1、使用位置参数"><a href="#1、使用位置参数" class="headerlink" title="1、使用位置参数"></a>1、使用位置参数</h3><p>要点：从以下例子可以看出位置参数不受顺序约束，且可以为{},只要format里有相对应的参数值即可,参数索引从0开，传入位置参数列表可用<code>*</code>列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = [<span class="string">'hoho'</span>,<span class="number">18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;&#125; ,age &#123;&#125;'</span>.format(<span class="string">'hoho'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="string">'my name is hoho ,age 18'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;1&#125; ,age &#123;0&#125;'</span>.format(<span class="number">10</span>,<span class="string">'hoho'</span>)</span><br><span class="line"><span class="string">'my name is hoho ,age 10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;1&#125; ,age &#123;0&#125; &#123;1&#125;'</span>.format(<span class="number">10</span>,<span class="string">'hoho'</span>)</span><br><span class="line"><span class="string">'my name is hoho ,age 10 hoho'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;&#125; ,age &#123;&#125;'</span>.format(*li)</span><br><span class="line"><span class="string">'my name is hoho ,age 18'</span></span><br></pre></td></tr></table></figure><h3 id="2、-使用关键字参数"><a href="#2、-使用关键字参数" class="headerlink" title="2、 使用关键字参数"></a>2、 使用关键字参数</h3><p>要点：关键字参数值要对得上，可用字典当关键字参数传入值，字典前加<code>**</code>即可<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hash = &#123;<span class="string">'name'</span>:<span class="string">'hoho'</span>,<span class="string">'age'</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;name&#125;,age is &#123;age&#125;'</span>.format(name=<span class="string">'hoho'</span>,age=<span class="number">19</span>)</span><br><span class="line"><span class="string">'my name is hoho,age is 19'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'my name is &#123;name&#125;,age is &#123;age&#125;'</span>.format(**hash)</span><br><span class="line"><span class="string">'my name is hoho,age is 18'</span></span><br></pre></td></tr></table></figure></p><h3 id="3、填充与格式化"><a href="#3、填充与格式化" class="headerlink" title="3、填充与格式化"></a>3、填充与格式化</h3><p>:[填充字符][对齐方式 &lt;^&gt;][宽度]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*&gt;10&#125;'</span>.format(<span class="number">10</span>)  <span class="comment">##右对齐</span></span><br><span class="line"><span class="string">'********10'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*&lt;10&#125;'</span>.format(<span class="number">10</span>)  <span class="comment">##左对齐</span></span><br><span class="line"><span class="string">'10********'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:*^10&#125;'</span>.format(<span class="number">10</span>)  <span class="comment">##居中对齐</span></span><br><span class="line"><span class="string">'****10****'</span></span><br></pre></td></tr></table></figure></p><h3 id="4、精度与进制"><a href="#4、精度与进制" class="headerlink" title="4、精度与进制"></a>4、精度与进制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:.2f&#125;'</span>.format(<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line"><span class="string">'0.33'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:b&#125;'</span>.format(<span class="number">10</span>)    <span class="comment">#二进制</span></span><br><span class="line"><span class="string">'1010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:o&#125;'</span>.format(<span class="number">10</span>)     <span class="comment">#八进制</span></span><br><span class="line"><span class="string">'12'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;0:x&#125;'</span>.format(<span class="number">10</span>)     <span class="comment">#16进制</span></span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:,&#125;'</span>.format(<span class="number">12369132698</span>)  <span class="comment">#千分位格式化</span></span><br><span class="line"><span class="string">'12,369,132,698'</span></span><br></pre></td></tr></table></figure><h3 id="5、使用索引"><a href="#5、使用索引" class="headerlink" title="5、使用索引"></a>5、使用索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>li</span><br><span class="line">[<span class="string">'hoho'</span>, <span class="number">18</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'name is &#123;0[0]&#125; age is &#123;0[1]&#125;'</span>.format(li)</span><br><span class="line"><span class="string">'name is hoho age is 18</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python之字符串格式化(format)&lt;br&gt;用法：&lt;/p&gt;
&lt;p&gt;　　它通过{}和:来代替传统%方式&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>如何使用yum来下载RPM包而不进行安装</title>
    <link href="https://CzsGit.github.io//blog/2017/07/10/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8yum%E6%9D%A5%E4%B8%8B%E8%BD%BDRPM%E5%8C%85%E8%80%8C%E4%B8%8D%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85.html"/>
    <id>https://CzsGit.github.io//blog/2017/07/10/如何使用yum来下载RPM包而不进行安装.html</id>
    <published>2017-07-10T13:03:20.000Z</published>
    <updated>2022-07-14T01:58:42.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="方法一-yum"><a href="#方法一-yum" class="headerlink" title="方法一:yum"></a>方法一:yum</h3><p>yum命令本身就可以用来下载一个RPM包，标准的yum命令提供了–downloadonly(只下载)的选项来达到这个目的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install --downloadonly &lt;package-name&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>默认情况下，一个下载的RPM包会保存在下面的目录中:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/var/</span>cache<span class="regexp">/yum/</span>x86_64<span class="regexp">/[centos/</span>fedora-version]<span class="regexp">/[repository]/</span>packages</span><br></pre></td></tr></table></figure></p><p>以上的[repository]表示下载包的来源仓库的名称(例如：base、fedora、updates)</p><p>如果你想要将一个包下载到一个指定的目录(如/tmp)：<br><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">$</span> <span class="comment">sudo</span> <span class="comment">yum</span> <span class="comment">install</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">downloadonly</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">downloaddir=/tmp</span> &lt;<span class="comment">package</span><span class="literal">-</span><span class="comment">name</span>&gt;</span><br></pre></td></tr></table></figure></p><p>注意，如果下载的包包含了任何没有满足的依赖关系，yum将会把所有的依赖关系包下载，但是都不会被安装。</p><p>另外一个重要的事情是，在CentOS/RHEL 6或更早期的版本中，你需要安装一个单独yum插件(名称为 yum-plugin-downloadonly)才能使用–downloadonly命令选项：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install yum-plugin-downloadonly</span></span><br></pre></td></tr></table></figure></p><p>如果没有该插件，你会在使用yum时得到以下错误：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Command</span> <span class="string">line</span> <span class="attr">error:</span> <span class="literal">no</span> <span class="string">such</span> <span class="attr">option:</span> <span class="bullet">--downloadonly</span></span><br></pre></td></tr></table></figure></p><h3 id="方法二-Yumdownloader"><a href="#方法二-Yumdownloader" class="headerlink" title="方法二: Yumdownloader"></a>方法二: Yumdownloader</h3><p>另外一个下载RPM包的方法就是通过一个专门的包下载工具–yumdownloader。 这个工具是yum工具包(包含了用来进行yum包管理的帮助工具套件)的子集。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install yum-utils</span></span><br></pre></td></tr></table></figure></p><p>下载一个RPM包：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yumdownloader &lt;package-name&gt;</span></span><br></pre></td></tr></table></figure></p><p>下载的包会被保存在当前目录中。你需要使用root权限，因为yumdownloader会在下载过程中更新包索引文件。与yum命令不同的是，任何依赖包不会被下载。</p><p><a href="http://ask.xmodulo.com/yum-download-rpm-package.html" target="_blank" rel="noopener">http://ask.xmodulo.com/yum-download-rpm-package.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;方法一-yum&quot;&gt;&lt;a href=&quot;#方法一-yum&quot; class=&quot;headerlink&quot; title=&quot;方法一:yum&quot;&gt;&lt;/a&gt;方法一:yum&lt;/h3&gt;&lt;p&gt;yum命令本身就可以用来下载一个RPM包，标准的yum命令提供了–downloadonly(只下载)的选项来达到这个目的。&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo yum install --downloadonly &amp;lt;package-name&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://CzsGit.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://CzsGit.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>python中的读方法</title>
    <link href="https://CzsGit.github.io//blog/2017/06/23/python%E4%B8%AD%E7%9A%84%E8%AF%BB%E6%96%B9%E6%B3%95.html"/>
    <id>https://CzsGit.github.io//blog/2017/06/23/python中的读方法.html</id>
    <published>2017-06-23T12:41:19.000Z</published>
    <updated>2022-07-14T01:58:42.805Z</updated>
    
    <content type="html"><![CDATA[<p>我们谈到“文本处理”时，我们通常是指处理的内容。Python 将文本文件的内容读入可以操作的字符串变量非常容易。文件对象提供了三个“读”方法： .read()、.readline() 和 .readlines()。每种方法可以接受一个变量以限制每次读取的数据量，但它们通常不使用变量。 .read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而 .read() 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。<br>.readline() 和 .readlines() 非常相似。它们都在类似于以下的结构中使用：<br><a id="more"></a><br>Python .readlines() 示例<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        fh = open( <span class="string">'c:\\autoexec.bat'</span>)       </span><br><span class="line">          <span class="keyword">for</span> line in fh.<span class="keyword">readlines</span>():                   </span><br><span class="line">            <span class="keyword">print</span>   line.readline() </span><br><span class="line">            和 .<span class="keyword">readlines</span>()之间的差异是后者一次读取整个文件，象 .<span class="keyword">read</span>()一样。</span><br><span class="line">            .<span class="keyword">readlines</span>()自动将文件内容分析成一个行的列表，该列表可以由 Python 的 <span class="keyword">for</span>... in ... 结构进行处理。</span><br><span class="line">            另一方面，.readline()每次只读取一行，通常比 .<span class="keyword">readlines</span>()慢得多。</span><br><span class="line">            仅当没有足够内存可以一次读取整个文件时，才应该使用.readline()。  </span><br><span class="line"></span><br><span class="line">写：</span><br><span class="line"></span><br><span class="line"><span class="keyword">writeline</span>()是输出后换行，下次写会在下一行写。<span class="keyword">write</span>()是输出后光标在行末不会换行，下次写会接着这行写</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">通过readline输出，对于比较大的文件，这种占用内存比较小。  </span><br><span class="line"><span class="comment">#coding:utf-8  </span></span><br><span class="line">  </span><br><span class="line">f = open(<span class="string">'poem.txt'</span>,<span class="string">'r'</span>)  </span><br><span class="line">result = list()  </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'poem.txt'</span>):  </span><br><span class="line">    line = f.readline()  </span><br><span class="line">    <span class="keyword">print</span> line  </span><br><span class="line">    result.append(line)  </span><br><span class="line"><span class="keyword">print</span> result  </span><br><span class="line">f.close()                  </span><br><span class="line">open(<span class="string">'result-readline.txt'</span>, <span class="string">'w'</span>).write(<span class="string">'%s'</span> % <span class="string">'\n'</span>.join(result))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8  </span></span><br><span class="line"><span class="string">'''''cdays-4-exercise-6.py 文件基本操作 </span></span><br><span class="line"><span class="string">    @note: 文件读取写入, 列表排序, 字符串操作 </span></span><br><span class="line"><span class="string">    @see: 字符串各方法可参考hekp(str)或Python在线文档http://docs.python.org/lib/string-methods.html </span></span><br><span class="line"><span class="string">'''</span>  </span><br><span class="line">  </span><br><span class="line">f = open(<span class="string">'cdays-4-test.txt'</span>, <span class="string">'r'</span>)                   <span class="comment">#以读方式打开文件  </span></span><br><span class="line">result = list()  </span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():                          <span class="comment">#依次读取每行  </span></span><br><span class="line">    line = line.strip()                             <span class="comment">#去掉每行头尾空白  </span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> len(line) <span class="keyword">or</span> line.startswith(<span class="string">'#'</span>):       <span class="comment">#判断是否是空行或注释行  </span></span><br><span class="line">        <span class="keyword">continue</span>                                    <span class="comment">#是的话，跳过不处理  </span></span><br><span class="line">    result.append(line)                             <span class="comment">#保存  </span></span><br><span class="line">result.sort()                                       <span class="comment">#排序结果  </span></span><br><span class="line"><span class="keyword">print</span> result  </span><br><span class="line">open(<span class="string">'cdays-4-result.txt'</span>, <span class="string">'w'</span>).write(<span class="string">'%s'</span> % <span class="string">'\n'</span>.join(result)) <span class="comment">#保存入结果文件</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们谈到“文本处理”时，我们通常是指处理的内容。Python 将文本文件的内容读入可以操作的字符串变量非常容易。文件对象提供了三个“读”方法： .read()、.readline() 和 .readlines()。每种方法可以接受一个变量以限制每次读取的数据量，但它们通常不使用变量。 .read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而 .read() 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。&lt;br&gt;.readline() 和 .readlines() 非常相似。它们都在类似于以下的结构中使用：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://CzsGit.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://CzsGit.github.io/tags/python/"/>
    
  </entry>
  
</feed>
